<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on 2014年 十一月 12日 星期三, 上午 9:37 -->
<!-- MuClient version 4.92 -->

<!-- Plugin "pkuxkx_p2palias_v20160728" generated by Plugin Wizard -->

<muclient>
<plugin
   name="pkuxkx_p2palias_v20160728"
   author="littleknife(非常道改)"
   id="c9acd48b7875883527e058d0"
   language="Lua"
   purpose="北大侠客行城际互联插件_v2016"
   save_state="y"
   date_written="2016-07-28 09:35:24"
   requires="4.43"
   version="1.0"
   >

</plugin>


<!--  Get our standard constants -->

<!--  Triggers  -->

<triggers>
  <trigger
   enabled="y"
   group="system"
   keep_evaluating="y"
   match="^(>)*( )*(你踩上铁索，向山涧的对面飘然而去\w*|你一咬牙，扳住崖上的岩石\w*|你扶着铁索，踏上桥板\w*)"
   name="sp_pause"
   regexp="y"
   script="do_walkstop"
   sequence="10"
   variable="sp_pause"
  >
  </trigger>
  <trigger
   enabled="y"
   group="boat"
   keep_evaluating="y"
   match="^(>)*( )*(你吸了口气，一声“船家”\w*|你使出吃奶的力气\w*|你没事不要乱往别人船上钻!\w*)"
   name="yb_wait"
   regexp="y"
   script="yellboat.wait"
   sequence="10"
   variable="yb_wait"
  >
  </trigger>
  <trigger
   enabled="y"
   group="home"
   lines_to_match="3"
   keep_evaluating="y"
   match="&quot;^[> ]*\s*.*\.*≡━◎个人档案◎.+\n\n【.+】.*「.*」(.*)\((.*)\)&quot;"
   multi_line="y"
   name="sp_home"
   regexp="y"
   script="alias_home"
   sequence="10"
   variable="sp_home"
  >
  </trigger>
  <trigger
   enabled="y"
   group="path_pause"
   keep_evaluating="y"
   match="^(> )*(你从下面爬了上来，衣服都烂了，看起来十分狼狈。|你从上面爬了下来，衣服都烂了，看起来十分狼狈。|六名雪山弟子一齐转动机关，吊桥便又升了起来。|大车停稳了下来，你可以下车\(xia\)了。|你身在半空，双手乱挥，只盼能抓到什么东西，这么乱挥一阵，又下堕下百馀丈。|你终于一步步的终于挨到了桥头\.|你终于来到了对面，心里的石头终于落地。|你听到声音的来源好象是从左侧\(left\)的墙壁\(wall\)中发出的。|你在左侧墙上的一块石缝中摸到了一处开关\(button\)。)$"
   name="walkgo_path_pause"
   regexp="y"
   script="addtri_2656"
   sequence="10"
   variable="walkgo_path_pause"
  >
  </trigger>
  <trigger
   enabled="y"
   group="boat"
   keep_evaluating="y"
   match="^(>)*( )*(艄公把踏脚板收起来\w*|船夫把踏脚板收起来\w*|小舟在湖中藕菱之间的水路\w*|你跃上小舟，船就划了起来。\w*|你拿起船桨用力划了起来。\w*)"
   name="yb_inboat"
   regexp="y"
   script="yellboat.inboatok"
   sequence="10"
   variable="yb_inboat"
  >
  </trigger>
  <trigger
   enabled="y"
   group="boat"
   keep_evaluating="y"
   match="^(>)*( )*艄公一把拉住你，.*"
   name="yb_needmoney"
   script="yellboat.needmoney"
   regexp="y"
   sequence="10"
   variable="yb_needmoney"
  >
  </trigger>
  <trigger
   enabled="y"
   group="system"
   keep_evaluating="y"
   match="^(>)*( )*(你终于来到了对面，心里的石头终于落地\w*|突然间蓬一声，屁股撞上了什么物事，\w*|你终于一步步的终于挨到了桥头\w*)"
   name="sp_resume"
   regexp="y"
   script="do_walkresume"
   sequence="10"
   variable="sp_resume"
  >
  </trigger>
  <trigger
   enabled="y"
   group="system"
   keep_evaluating="y"
   match="^[> ]*(你小心翼翼往前挪动，遇到艰险难行处，只好放慢脚步。\w*|青海湖畔美不胜收，你不由停下脚步，欣赏起了风景。\w*|你不小心被什么东西绊了一下\w*|你的动作还没有完成，不能移动\w*)"
   name="walkgo_blocker"
   regexp="y"
   script="walkgo.blocker"
   sequence="10"
   variable="walkgo_blocker"
  >
  </trigger>
  <trigger
   enabled="y"
   group="system"
   keep_evaluating="y"
   match="^[> ]*设定环境变量：no_more = &quot;walkgo&quot;$"
   name="walkgo_stepcmd"
   omit_from_output="y"
   regexp="y"
   script="walkgo.stepcmd"
   sequence="10"
   variable="walkgo_stepcmd"
  >
  </trigger>
  <trigger
   enabled="y"
   group="system"
   keep_evaluating="y"
   match="^[> ]*设定环境变量：no_more = &quot;rewalk&quot;$"
   name="walkgo_rewalk"
   omit_from_output="y"
   regexp="y"
   script="do_walkcontinue"
   sequence="10"
  >
  </trigger>
  <trigger
   enabled="y"
   group="boat"
   keep_evaluating="y"
   match="^(>)*( )*(艄公说“到啦，上岸吧”.+|船夫对你说道：“到了\w*|你朝船夫挥了挥手.+|小舟终于划到近岸.+|.+你跨上岸去。\w*|不知过了多久，船终于靠岸了，你累得满头大汗。\w*)"
   name="yb_over"
   regexp="y"
   script="yellboat.over"
   sequence="10"
   variable="yb_over"
  >
  </trigger>
  <trigger
   enabled="y"
   group="boat"
   keep_evaluating="y"
   match="^(>)*( )*(一叶扁舟缓缓地驶了过来，艄公将一块踏脚板.+|岸边一只渡船上的老艄公说道：正等着你.+)"
   name="yb_come"
   regexp="y"
   script="yellboat.boatcoming"
   sequence="10"
   variable="yb_come"
  >
  </trigger>
  <trigger
   enabled="y"
   group="walkbusy"
   keep_evaluating="y"
   match="^(> )*你不忙$"
   name="walkgo_busy"
   regexp="y"
   script="walk_busyover"
   sequence="10"
   variable="walkgo_busy"
  >
  </trigger>
</triggers>

<!--  Aliases  -->

<aliases>
  <alias
   name="alias_walkallstop"
   script="do_walkallstop"
   match="wkallstop"
   enabled="y"
   group="path"
   sequence="100"
  >
  </alias>
  <alias
   name="alias_yellboat"
   script="yellboat.main"
   match="yellboat"
   enabled="y"
   group="path"
   sequence="100"
  >
  </alias>
  <alias
   name="alias_fullpath"
   script="aliascmd.fullpath"
   match="fullpath (\w+[-,]\w+[^:])$"
   enabled="y"
   group="path"
   regexp="y"
   sequence="100"
  >
  </alias>
  <alias
   name="aliascmd_gancheon"
   script="aliascmd.gancheon"
   match="gancheon"
   enabled="y"
   group="path"
   sequence="100"
  >
  </alias>
<alias
   name="aliascmd_gancheoff"
   script="aliascmd.gancheoff"
   match="gancheoff"
   enabled="y"
   group="path"
   sequence="100"
  >
  </alias>
  <alias
   name="mapper_locate"
   script="mapper_locate"
   match="#loc"
   enabled="y"
   sequence="100"
  >
  </alias>
  <alias
   name="alias_walk_busy"
   script="alias_walk_busy"
   match="^walk_busy\((.*)\)"
   enabled="y"
   regexp="y"
   sequence="100"
  >
  </alias>
  <alias
   name="alias_ganche_avoid"
   script="alias_ganche_avoid"
   match="^ganche_avoid\((.*)\)"
   enabled="y"
   regexp="y"
   sequence="100"
  >
  </alias>
  <alias
   name="mapper_gotonode2"
   script="mapper_gotonode2"
   match="gt"
   enabled="y"
   sequence="100"
  >
  </alias>
  <alias
   name="mapper_getsid"
   script="mapper_getsid"
   match="#sid (.*)"
   enabled="y"
   regexp="y"
   sequence="100"
  >
  </alias>
  <alias
   name="mapper_recordhere"
   script="mapper_recordhere"
   match="#rec"
   enabled="y"
   sequence="100"
  >
  </alias>
  <alias
   name="mapper_gotonode"
   script="mapper_gotonode"
   match="gt (.*)"
   enabled="y"
   regexp="y"
   sequence="100"
  >
  </alias>
  <alias
   name="alias_path_home"
   script="home"
   match="^home\((.*)\)"
   enabled="y"
   regexp="y"
   sequence="100"
  >
  </alias>
  <alias
   name="alias_walkquickon"
   script="aliascmd.walkquickon"
   match="quickon"
   enabled="y"
   group="path"
   sequence="100"
  >
  </alias>
    <alias
   name="alias_walkquickoff"
   script="aliascmd.walkquickoff"
   match="quickoff"
   enabled="y"
   group="path"
   sequence="100"
  >
  </alias>
  <alias
   name="mapper_editlinks"
   script="mapper_editlinks"
   match="#edit"
   enabled="y"
   sequence="100"
  >
  </alias>
  <alias
   name="alias_walkstop"
   script="do_walkstop"
   match="wks"
   enabled="y"
   group="path"
   sequence="100"
  >
  </alias>
  <alias
   name="mapper_addLinknode"
   script="mapper_addLinknode"
   match="#add"
   enabled="y"
   sequence="100"
  >
  </alias>
  <alias
   name="alias_walkgo"
   script="do_walkresume"
   match="wkg"
   enabled="y"
   group="path"
   sequence="100"
  >
  </alias>
  <alias
   name="alias_walkcontinue"
   script="do_walkcontinue"
   match="wkc"
   enabled="y"
   group="path"
   sequence="100"
  >
  </alias>
  <alias
   name="mapper_deleteNode"
   script="mapper_deleteNode"
   match="#del (.*)"
   enabled="y"
   regexp="y"
   sequence="100"
  >
  </alias>
  <alias
   name="alias_path"
   script="aliascmd.cmd"
   match="^(\w+[-,]\w+[^:])$"
   enabled="y"
   group="path"
   regexp="y"
   sequence="100"
  >
  </alias>
  <alias
   name="alias_path_pause"
   script="alias_path_pause"
   match="^path_pause\((.*)\)"
   enabled="y"
   regexp="y"
   sequence="100"
  >
  </alias>
  <alias
   name="alias_roomskip"
   script="alias_room_skip_lb"
   match="^room_skip\((.*)\)$"
   enabled="y"
   regexp="y"
   sequence="100"
  >
  </alias>
</aliases>

<!--  Variables  -->

<variables>
  <variable name="roomname">井底</variable>
</variables>

<!--  Script  -->


<script>
<![CDATA[

-----************************************************************************************************************************************************************
-----Name		::	Walk Mode	And Edit Mode for pkuxkx_p2palias::	城际互联行走模块及库编辑模块。
-----Author		::	littleknife
-----Ver			::	201411091222
-----************************************************************************************************************************************************************
local README_DOC=[[
---=======================================---
欢迎使用北侠城际互联pkuxkx_p2palias_2016	[直达模块_sqlite3]版。
---=======================================---
使用说明：
	（1）研习传统行走模式：yz,fuzhou模式。即直接键入简写代码既可以到达目的地。前提是你在对应的起始节点处。
	（2）直达模式（goto）：gt 目的地ID或简写代码。
	（3）所在节点查询：gt here。查询你现在的地点是否是有效节点。
	（3）节点列表：gt list。当前可直达节点列表，输出至新窗口（Notepad）（全称ID及对应简写代码SID表）
	（4）显示本说明：gt+空格。
	
			注意：由于部分采用导入的旧库表进入新节点库的方式，对节点没有描述信息，故在当前节点（你所站在的节点是导入的）上键入gt xxx，或#loc
					将重新录制当前节点信息以完善节点库。
			形如：你用yz,fuzhou方式走到fuzhou，然后键入#loc或gt yz，由于fuzhou这个节点信息没有入库，将提示你重新录制当前节点信息。
			故此，希望保持原节点信息，请记住：原当前节点全称ID、简称ID、原节点路线（选择不编辑子节点将保持原路线）。
			以便录入此节点时输入对应信息，以覆盖旧信息。当你逐渐完善了节点库，最终将完全实现节点上的P2P。
	
	详细说明请查阅http://pkuxkx.net

]]

----******************************************************************************
----hook.mod 部分函数
----******************************************************************************
hooks={}
_hooklist={}
_hookarglist={}
----有无hook函数
hashook=function(str)
	if _hooklist[str] ==nil then
		return false
	else
		return true
	end
end

----hook一个函数及其参数

hook=function(str,callback,...)
----hook函数到list,str:list中的名字，callback:函数名,...函数参数。
	_hooklist[str]=callback
	if callback==nil then
		_hookarglist[str]=nil
	else
		_hookarglist[str]={...}
	end
end

unhookall=function()
	_hooklist={}
	_hookarglist={}
end

callhook=function(str,removehook)
	----调用hook函数str，removehook:true or false ,true删除函数。
	---callhook("str",true)---调用hook函数同时清除其存储。
	thook=_hooklist[str]
	thookarg=_hookarglist[str]
	if removehook==true then
		hook(str,nil)
	end
	if thookarg~=nil then
		call(thook,unpack(thookarg))
	else
		call(thook)
	end
end

call=function(func,...)
	local call_args={}
	for _, v in ipairs{...} do
		table.insert(call_args, v)
	end --for
	if (func~=nil) then
		func(unpack(call_args))
	end
end

----******************************************************************************
----system.mod 部分函数
----******************************************************************************
function ltrim (r, s)
  if s == nil then
    s, r = r, "%s+"
  end
  return (r.gsub (s, "^" .. r, ""))
end

function rtrim (r, s)
  if s == nil then
    s, r = r, "%s+"
  end
  return (r.gsub (s, r .. "$", ""))
end
runre=rex.new("([^;*\\\\]+)")
cmd_limit=35
run=function(str)
	ResetTimer("on_steptimeout")
	if ((str=="")or(str==nil)) then return end
	SetSpeedWalkDelay(math.floor(1000/cmd_limit))
	_cmds={}
	local i=0
	n=runre:gmatch(str,function (m, t)
		i=i+1
		_cmds[i]=m
	end)
	if (_cmds==nil) then return end
	for i, cmd in pairs (_cmds) do
		if cmd=="#gift" then
			if chatroom~=nil then
				cmd="enter "..chatroom
			end
		end
		Queue(cmd,0)
		if walkecho==true then Note(cmd) end
	end
end

function table_is_empty(t)
	----table is nothing,then it return true,or return false.
	if t==nil or t=="" then return true end----t=nil 即为空

        return _G.next( t ) == nil

end
function table_is_equal(list1,list2)
----说明：比较两个数字项表格是否相等。
	local result=-1
	for i,value in pairs(list1) do

			result=simTableIndex(value,list2)
			----print("result1 ",result)
			if result==-1 then return false end

	end
	----------------------
	for i,value in pairs(list2) do

			result=simTableIndex(value,list1)
			-----print("result2 ",result)
			if result==-1 then return false end

	end

		return true

	---------------------------
end
function table_is_contain(father_list,child_list)
----说明：比较两个数字项表格是否fathter_list包含child_list。
	local result=-1
	for i,value in pairs(child_list) do

			result=simTableIndex(value,father_list)
			-----print("result2 ",result)
			if result==-1 then return false end

	end
		return true
end

function simTableIndex(str,list)
  for i,value in pairs(list)  do
    if (value==str) then
      return i
    end
  end
  return -1
end

addtri=function(triname,trimatch,trigroup,triscript,triflag,trisequence)
---------------------------------------------------------------------------------
			local flag_base=1064-------KeepEvaluating = 8,RegularExpression = 32,Replace = 1024
			local flag_base_enable=1065-------KeepEvaluating = 8,RegularExpression = 32,Replace = 1024,Enabled = 1
			local flag_base_temp=1065+trigger_flag.Temporary-------Temporary = 16384
			
			if triflag==nil or triflag=="" then triflag=flag_base_enable end
			if trisequence==nil then trisequence=10 end
			if type(triscript)=="string"	then
						tri_returnvalue=check(AddTriggerEx(triname, trimatch, "", triflag, -1, 0, "",  triscript, 0, trisequence))
			end
			if type(triscript)=="function"	then
		
				local Addtri_fun = "addtri_" .. GetUniqueNumber ()
				-----print("Addtri_fun::>>",Addtri_fun)
				_G [Addtri_fun] = triscript
				tri_returnvalue=check(AddTriggerEx(triname, trimatch, "", triflag, -1, 0, "",  Addtri_fun, 0, trisequence))
			end	
			SetTriggerOption(triname,"group",trigroup)
			return tri_returnvalue
end
----******************************************************************************
infoend=function(infoendfun,...)
----print("infoend>>>!!!!")
			hook("infoend_fun",infoendfun,...)----函数hook
					_infod={}
					_infod.args={}
			for _, v in ipairs{...} do
				table.insert(_infod.args, v)
			end --for
			wait.make(function()
						run("set no_more infoend")
						local l,w=wait.regexp('^(> |)\\s*设定环境变量：no_more = "infoend"$',5)
								if l==nil then
										print("[:system:]::Error::infoend...>>catch nil")
										infoend(infoendfun,unpack(_infod.args))
										return
								end							
								if string.find(l,"infoend") then
								------print("string.find infoend, hashook('infoend_fun')",hashook("infoend_fun"))
										if hashook("infoend_fun")==true then
													callhook("infoend_fun",true)
												return
										end
								end
							print("[::system:]....infoend fun is null.")
							return
								---infoend(infoendfun,unpack(_infod.args))								
			end)
end
-----************************************************************************************************************************************************************
-----************************************************************************************************************************************************************


print("Loading	pkuxkx_p2palias_v2016	EditorMode.....OK!!")

require "wait"
require "tprint"
ro=DatabaseOpen ("xkxalias_db",GetInfo (56) .. "pkuxkx_p2palias_v2016.db", 6)
local Example_DataTable=[[
----表格数据库存储格式：
	simplified_name={----*********城市简码表 START***********************-------

	["hhbeiwest"]=	"hhxb",	["hhnanwest"]=	"hhxn",	["hhnandukou1"]=	"hhbdk",	["hhbeidukou1"]=	"hhndk",
	["hhnangudu"]=	"hhngd",	["hhbeigudu"]=	"hhbgd",	["mengjindu"]=	"mjd",	["fenglingdu"]=	"fld",
	["hhnandukou4"]=	"hhnd4",	["hhbeidukou4"]=	"hhbd4",	["hhbeieast"]=	"hhdb",	["hhnanruhaikou"]=	"hhrhk",
	["cjnanwest"]=	"ccxn",	["cjbeiwest"]=	"ccxb",	["lingji"]=	"lj",	["lingjin"]=	"ljin",
	}
	
	
	pathlib_table={-----*****地图函数库********--------
	-----****************************************************--------
	["hhbeiwest"]={	--::>黄河西北<::--,简码：[>>hhxb<<]
		["NodeName"]="黄河西北",
		["ZoneName"]="黄河",
		["ZoneId"]="huanghe",
		["LinkNodes"]={
			["hhbeidukou1"]=	"e;#3 ne",
			},
		},
	["hhnanwest"]={	--::>黄河西南<::--,简码：[>>hhxn<<]
		["NodeName"]="黄河西南",
		["ZoneName"]="黄河",
		["ZoneId"]="huanghe",
		["LinkNodes"]={
			["hhnandukou1"]=	"e;#3 ne",
			},
		},
		}


]]
--***********************************************************************************
-----**************************************************************--------
----房间信息抓取====START====
----***********************************************************************************
WeatherDesc={
					"东方的天空已逐渐发白。","太阳刚从东方的地平线升起。","太阳正高挂在东方的天空中。",
					"现在是正午时分，太阳高挂在你的头顶正上方。",	"太阳正高挂在西方的天空中。",
					"一轮火红的夕阳正徘徊在西方的地平线上。",
					"夜幕低垂，满天繁星。","夜幕笼罩著大地。","屏风已被拉开，露出一条长长的甬道。",
					"一片浓雾中，什么也看不清。",
}

local Room_INFO={ --数据结构
				relation="",
				roomname="",
				description="",
				weather="",
				exits="",
				zone="",
				opentime="",
				opendir="",
}
---------------------------------------
local R={} --实例对象
Room={
	new=function()
		local _Room={}
		setmetatable(_Room,{__index=Room})
		return _Room
	end,
	interval=5,
	timeout=20,
	help="格式：帮助文件",
	-------------------------------------
	roomname="",
	zone="",
	Catch=function()
			world.DeleteTriggerGroup("q_Room")
			coroutine.resume(Room.catch_co)
	end,
	catch_co=nil,
}

function Room:CatchEnd()
			print("mapper:..[CatchEnd]..")
end

function Room:CatchFail()
			print("mapper:..[CatchFail]..")
end

function Room:CatchStart()
		self:update()
		Room.catch_co=coroutine.create(function()
					R={}
					setmetatable(R,{__index=Room_INFO})
					world.EnableTriggerGroup("q_Room",false)
					self:Look()
					coroutine.yield() --挂起
					self:CatchEnd()
				end)
  coroutine.resume(Room.catch_co)
end
-----------------------------------------------
function Room:Look()
		        EnableTrigger("Room_delay",1)
				EnableTrigger("Room_relation",1)
				EnableTrigger("Room_name",1)
				------print("--->>>look<<<---")
				run("look")
end

function Room:Relation(n,l,w)

				local relation=Trim(w[2])
				
				if R.relation==nil then
				   R.relation= ""
				end
				--过滤 filter-->>--				
				relation = string.gsub(relation, ">", "")
				local i=string.find(relation,"走了过来。")
				local j=string.find(relation,"离开。")
				local k=string.find(relation,"请使用backup命令来备份。")
				local r1=string.find(relation,"这里没有任何明显的出路")
				local r2=string.find(relation,"这里明显的出口是")
				local r3=string.find(relation,"这里唯一的出口是")
				if i~=nil or j~=nil or k~=nil or r1~=nil or r2~=nil or r3~=nil then				
						relation=""
				end
				--<<--过滤 filter
				R.relation=R.relation .. relation --累计变量

				if roomnameline~=nil and roomnameline~="" then
						--print("roomnameline:",Trim(roomnameline))
						---R.relation=string.gsub(R.relation,roomnameline,"")
						---gsub和Replace还是有区别201112211，上语句不可用。
						R.relation=Replace(R.relation, roomnameline,"", true)
				end


				Room.relation=R.relation
end

function Room:Name(n,l,w)
			local  roomname=w[1]
			roomnameline=Trim(l)
			world.EnableTrigger("Room_relation",false);
			world.EnableTrigger("Room_name",false)
			world.EnableTrigger("Room_desc",true);
			world.EnableTrigger("Room_weather",true);
			world.EnableTrigger("Room_exits",true);
			
			roomname = string.gsub(roomname, " ", "")
			roomname = string.gsub(roomname, ">", "")
			roomname=Trim(roomname)
			
			R.roomname=roomname
			Room.roomname=roomname
			
			SetVariable("roomname",Room.roomname)
			if Room.roomname=="岳飞墓" or Room.roomname=="书院" then
					run("abcd;abcd;abcd")
			end
			
			--print("房间名:",R.roomname)
end

function Room:Description_trigger(n,l,w)
				local desc=w[1]
				
				if R.description==nil then
				   R.description=""
				end
				
				local omit_exits1=string.find(desc,"这里没有任何明显的出路")
				local omit_exits2=string.find(desc,"这里明显的出口是")
				local omit_exits3=string.find(desc,"这里唯一的出口是")
				local omit_page=string.find(desc,"未完继续")
				local omit_weather=string.find(desc,"」:")
				
				if omit_page~=nil or omit_exits1~=nil or omit_exits2~=nil or omit_exits3~=nil or omit_weather~=nil then
								desc=""
				end
				
				R.description=R.description .. Trim(desc)
				if weatherline~=nil and weatherline~="" then
					R.description=string.gsub(R.description,Trim(weatherline),"")
				end
				for k,v in pairs(WeatherDesc) do
					R.description=string.gsub(R.description,Trim(v),"")
				end

			Room.description=R.description
			---print(R.description)
			
end
--pkuxkx里需要，xkx内没必要有此内容。但Locate里可以用来确定时间
function Room:Weather(n,l,w)
				weather=w[1]				
				weatherline=l
				R.weather=Trim(weather)
				Room.weather=R.weather
				world.EnableTrigger("Room_desc",0);
				----print("R.weather::[",R.weather,"]")
				if string.find(l,"你可以看看") and R.roomname=="古墓墓洞" then
					infoend(Room.Catch)
				end

  end
  
function Room:Exits(n,l,w)

				if string.find(l,"这里没有任何明显的出路") then
					exits="look"
				else
					exits=w[2]
				end
				
				exits=string.gsub(exits,"。","") --去除句号
				exits=string.gsub(exits," ","")
				exits=string.gsub(exits,"、", ";")
				exits=string.gsub(exits, "和", ";")

				local t={}
				t=utils.split(exits,";")
				s=""
				for i,v in ipairs(t) do
							if Trim(v)~="" then
								s=s..Trim(v)..";"
							end
				end
				R.exits=s
				Room.exits=R.exits
				
				world.EnableTriggerGroup("q_Room",false)

				infoend(Room.Catch)
				
end
-----------------------------------------------
function Room:update()

		local  Room_triggerlist={
		    {name="Room_delay",regexp="^(> |)风景要慢慢的看\\w*",script=function()    self:Look()  end,},
		    {name="Room_relation",regexp="^(> |)\\s+(.*)$",script=function(n,l,w)    self:Relation(n,l,w)  end,},
		    {name="Room_name",regexp="^(.*)-\\s*$",script=function(n,l,w)    self:Name(n,l,w)  end,},
		    {name="Room_desc",regexp="^(.*)$",script=function(n,l,w)    self:Description_trigger(n,l,w)  end,},
			{name="Room_exits",regexp="^\\s*这里(明显|唯一)的出口是(.*)$|^\\s*这里没有任何明显的出路\\w*",script=function(n,l,w)    self:Exits(n,l,w)  end,},
			{name="Room_weather",regexp="^\\s*「.*」: (.*)。$|^\\s*你可以看看\\w*",script=function(n,l,w)    self:Weather(n,l,w)  end,},
			{name="Room_weather2",regexp="^一片浓雾中，什么也看不清。$",script=function(n,l,w)    self:Weather(n,l,w)  end,},
			   
		}

---Creat Trigger-->>
		for k,v in pairs(Room_triggerlist) do
		----print(k,v)
			addtri(v.name,v.regexp,"q_Room",v.script)
		end

---End Creat Trigger--<<

end

----***********************************************************************************
----房间信息抓取====THE END====
----***********************************************************************************
local function time_define(w)
    --print("define:",w)
    if w==nil or w=="" then
       return nil
    end
	
    if string.find(w,"夜晚") or string.find(w,"深夜") or string.find(w,"夜幕") or string.find(w,"午夜") then
      return false
    end
    if string.find(w,"凌晨") then
       --无法判别 还是需要按时间判别
       return nil
    end
    return true
end
----***********************************************************************************
----***********************************************************************************
----房间定位====START====
----*********************************************************************************** 
function Locate()  --确定是否查询嵌套子房间
      --模糊查询
   --1
   --useage:zone_list={"福州","嘉兴","扬州",}

     --local sql="SELECT distinct nodeno,relation,nodename,description,exits,zone,nodeid,s_id from MUD_Node where nodename='"..R.roomname.."'"
	 --local sql=string.format("SELECT `_rowid_`,* FROM `MUD_Node` WHERE 1=1 AND `nodename` LIKE '%s' AND `description` LIKE '%s' AND `exits` LIKE '%s' ORDER BY `_rowid_` ASC LIMIT 0, 50000;", R.roomname, R.description, R.exits)
	local sql=string.format("SELECT `_rowid_`,* FROM `MUD_Node` WHERE 1=1 AND `nodename` LIKE '%s' AND `description` LIKE '%s' ORDER BY `_rowid_` ASC LIMIT 0, 50000;", R.roomname, R.description)
	--print(sql)
	if string.find(R.description,"这里遭受蒙古兵的洗劫后") then
		R.zone = "襄阳"
		sql=string.format("SELECT `_rowid_`,* FROM `MUD_Node` WHERE 1=1 AND `zone` LIKE '%s'  AND `nodename` LIKE '%s' ORDER BY `_rowid_` ASC LIMIT 0, 50000;", R.zone, R.roomname)
	end
	--print(sql)
   -- prepare a query

    rp=DatabasePrepare ("xkxalias_db", sql)

        -- execute to get the first row
        -- rc = DatabaseStep ("xkxalias_db")  -- read first row
	
   rc = DatabaseStep ("xkxalias_db")
   
        local exitstr=rtrim(";",R.exits)
        local cur_room_exits={}
            cur_room_exits=utils.split(exitstr,";")----当前房间出口信息表格。

	local nodeno={}
	local nodeID={}
	local nodeSID={}
	local nodezone={}
	if string.find(R.description, "这里是一家店铺，专替客人制作泥人。") then
		table.insert(nodeno,2370)
		table.insert(nodezone,"洛阳")
		table.insert(nodeID,"luoyangnirenpu")
		table.insert(nodeSID,"lynrp")
	else
		rooms_found = 0
		while rc == 100 do
				values = DatabaseColumnValues ("xkxalias_db")
			rooms_found = rooms_found + 1
				--tprint(values)
			 ----values[1]=nodeno,values[2]=relation,values[3]=roomname,values[4]=description
			 ----values[5]=exits,values[6]=zone,values[7]=nodeid,values[8]=s_id
			 local exits_is_same=false
			 local desc_is_same=false
			 local relation_is_same=false
			    --tprint(values)
				local db_exits=rtrim(";",values[6])
				local tb_db_exits=utils.split(db_exits,";")        ------------------数据库存储的exits表
				--tprint(tb_db_exits)
				--tprint(cur_room_exits)
				--print(Trim(R.relation))
				--if table_is_contain(cur_room_exits,tb_db_exits) then    -----（1）exits对比，当前出口信息是否包含库信息。
				if db_exits == exitstr then    -----（1）exits对比，当前出口信息是否包含库信息。
						exits_is_same=true
				end---if exits
				--print(exits_is_same)
				if Trim(values[5])==Trim(R.description) or string.find(Trim(values[5]),Trim(R.description))~=nil or string.find(R.description,"这里遭受蒙古兵的洗劫后") then----（2）先比较description。
						desc_is_same=true
				end---if 
				if Trim(values[3])==Trim(R.relation) or string.find(Trim(values[3]),Trim(R.relation))~=nil or values[3]..values[3] == R.relation or string.find(R.relation, "泥人")then----（3）再对比R.relation。
						relation_is_same=true
				end--if relation
				--print(R.relation,values[3])
				--print(relation_is_same)
				----if (desc_is_same==true and relation_is_same==true) or (exits_is_same==true and relation_is_same==true) or (exits_is_same==true and desc_is_same==true)  then
				---至少有两项相同，则认为匹配正确。
				if desc_is_same==true and relation_is_same==true and exits_is_same==true  then
				---三项都一致，才认为匹配。
								table.insert(nodeno,values[2])
								table.insert(nodezone,values[7])
								table.insert(nodeID,values[8])
								table.insert(nodeSID,values[9])
								
				end--if con

			  rc = DatabaseStep ("xkxalias_db")  -- read next row
		end -- while loop
		--print(rooms_found, nodeno[1])
		if rooms_found == 1 and nodeno[1] == nil then
			table.insert(nodeno,values[2])
			table.insert(nodezone,values[7])
			table.insert(nodeID,values[8])
			table.insert(nodeSID,values[9])
		end
	end
   -- finished with the statement
   DatabaseFinalize ("xkxalias_db")
	-----local opentime=time_define(R.weather)
    ---print("opentime:",opentime,nodeno[1])
	if table_is_empty(nodeno)~=true then
		print("[:mapper:]::当前节点号::[ ",nodeno[1]," ](ID:"..nodeID[1]..",SID:"..nodeSID[1]..")")
	end
   return table.getn(nodeno),nodeno,table.getn(nodeID),nodeID,nodezone
end
----***********************************************************************************
----***********************************************************************************
mapper_locate=function()
    LocateHere()
end
AddAlias("mapper_locate","#loc","",alias_flag.Enabled + alias_flag.Replace,"mapper_locate")
----***********************************************************************************
	local INPUT_TABLE_SETTINGS={
         box_width = 500,
         box_height = 150, 
         prompt_height = 20,
         reply_width = 500,
         reply_height = 20,
         max_length = 2000,}
		 
function LocateHere(CallBack)

		 
     local _R={}
    _R=Room.new()
    _R.CatchEnd=function()
					local count,nodeno,_countID,nodeID,roomzone=Locate()
					if count==0 then
												local	_editnode_yesno = utils.umsgbox ( "库内未查询到该节点，【是否】将此地录制入库？", "节点录制","yesno","?")
												if _editnode_yesno=="yes"	then
														nodeno[1]=NewNode()
												else
												utils.umsgbox ( "放弃将此地作为新节点录制入库。", "节点录制")
												end
					elseif count==1 then
					print("唯一节点，节点号>>[",nodeno[1],"]<<  ::区域::>[",roomzone[1],"]<")
						------------------------------------------------------------------
						local _tb={}
						table.insert(_tb,nodeno[1])
						local curlinknolist=get_Linknodeno_list(_tb)
						if  table_is_empty(curlinknolist)==true then print("::此节点没有关联节点::") end
						------------------------------------------------------------------
						if CallBack~=nil then CallBack() end
					else
						for i,r in ipairs(nodeno) do
							print("重复房间：",i,": 房间号::[",r,"]::",nodeID[i],">::区域::<",roomzone[i])
							local _tb={}
							table.insert(_tb,r)
							local curlinknolist=get_Linknodeno_list(_tb)
							if  table_is_empty(curlinknolist)==true then print("::此节点没有关联节点::") end
							------------------------------------------------------------------
							if CallBack~=nil then CallBack() end						
						end
				   end

    end
    _R:CatchStart()
end
----***********************************************************************************
----***********************************************************************************
----房间定位====THE	END===
----***********************************************************************************
----***********************************************************************************
----节点录制====THE	START===
----***********************************************************************************
function get_Nodenocount()
   local names={}
   DatabasePrepare ("xkxalias_db", "SELECT NodeNoCount from MUD_NodeNoCount")
   -- find the column names
   rc = DatabaseStep ("xkxalias_db")
   values = DatabaseColumnValues ("xkxalias_db")
   local nodeno=values[1]
   print ("nodeno",nodeno)
   DatabaseFinalize ("xkxalias_db")
   local sql="update MUD_NodeNoCount set NodeNoCount=NodeNoCount+1"
   DatabaseExec ("xkxalias_db",sql)
   DatabaseFinalize ("xkxalias_db")
   --print(nodeno)
   return nodeno
end

function get_NodeNo(nodeid)
----给出nodeid对应的节点编号。nodeid应为MUD_Node表里存在的记录。
local _nodeno=-999
local _nodename="未命名"
local _sid

if nodeid==nil or nodeid==-999 then 
		return _nodeno,_nodename
end
    local sql="select nodeno,nodename,nodeid,s_id from MUD_Node where nodeid='"..nodeid.."'"

   DatabasePrepare ("xkxalias_db", sql)
   rc = DatabaseStep ("xkxalias_db")
   
   while rc == 100 do
     values = DatabaseColumnValues ("xkxalias_db")
        _nodeno=values[1]
		_nodename=values[2]
		_sid=values[4]
     rc = DatabaseStep ("xkxalias_db")  -- read next row
   end -- while loop
   DatabaseFinalize ("xkxalias_db")
   return _nodeno,_nodename,_sid
end

function get_Linkspath(nodeno,linknodeno,linknodeid)
	local result=nil
	local result_ID=nil
	local sql
	
	if nodeno==nil	then
		return	result,result_ID
	end
	if linknodeno==-999 and linknodeid~=nil and string.len(linknodeid)>0 then
			------有linknodeid，无linknodeno
			result_ID=linknodeid
			sql="SELECT path,linknodeid from MUD_Links where nodeno="..nodeno.." and linknodeid='"..linknodeid.."'"
	else
			sql="SELECT path,linknodeid from MUD_Links where nodeno="..nodeno.." and linknodeno="..linknodeno	
	end--if linknodeno
	
	rp=DatabasePrepare("xkxalias_db",sql)
	rc=DatabaseStep("xkxalias_db")
	----print("get_Linkspath,sql,rc",sql,rc)
	while rc==100 do
			values=DatabaseColumnValues("xkxalias_db")
			result=values[1]
			result_ID=values[2]
			rc=DatabaseStep("xkxalias_db")
	end--while 
	DatabaseFinalize("xkxalias_db")
	return result,result_ID
end

function delete_Linkspath(nodeno,linknodeno,linknodeid)
	local sql
	
	if nodeno==nil	then
		print("[:DELETE Links:]....nodeno is nil!....")
		return false
	end
	if linknodeno==-999 and linknodeid~=nil and string.len(linknodeid)>0 then
			------有linknodeid，无linknodeno
			sql="DELETE from MUD_Links where nodeno="..nodeno.." and linknodeid='"..linknodeid.."'"			
	else
			sql="DELETE from MUD_Links where nodeno="..nodeno.." and linknodeno="..linknodeno	
	end--if linknodeno
		DatabaseExec ("xkxalias_db",sql)
		DatabaseFinalize ("xkxalias_db")
		pathlib_table,simplified_name=Output_Table_fromLib()
	print("::删除记录::",sql)
	return true
end

function get_Duplicate_nodeid()  
      --查找是否有重复的nodeid或nodeSID。

     local sql="SELECT nodeid,s_id from MUD_Node "
   -- prepare a query

    rp=DatabasePrepare ("xkxalias_db", sql)

        -- execute to get the first row
        -- rc = DatabaseStep ("xkxalias_db")  -- read first row
	
   rc = DatabaseStep ("xkxalias_db")
	local Dup_nodeID={}
	local Dup_nodeSID={}
	local _nodeid_list={}
	local _nodesid_list={}
   while rc == 100 do
				values = DatabaseColumnValues ("xkxalias_db")
				table.insert(_nodeid_list,values[1])
				table.insert(_nodesid_list,values[2])
			  rc = DatabaseStep ("xkxalias_db")  -- read next row
   end -- while loop
   DatabaseFinalize ("xkxalias_db")
	for k,v in pairs(_nodeid_list) do
				for i,j in pairs(_nodeid_list) do
				
						if v==j and k~=i then
						table.insert(Dup_nodeID,v)
						end
				end--for
				for i,j in pairs(_nodesid_list)	do
						if v==j and k~=i then 
						table.insert(Dup_nodeSID,v)
						end
				end--i,j
	end--for
   -- finished with the statement
   
   return table.getn(Dull_nodeID),Dull_nodeID, table.getn(Dull_nodeSID),Dull_nodeSID
end

function insert_newpath(nodeno,linknodeno,path,linknodeid)
		local sql
	if nodeno==nil or nodeno==-999 then return "NODE HAS ERROR!";	end
	if linknodeno=="" or linknodeno==nil or linknodeno==-999 then
			linknodeno=get_NodeNo(linknodeid)
	end
	--------------------------------------------------------------------
		local haspath=get_Linkspath(nodeno,linknodeno,linknodeid)

		----print("haspath::,linknodeno",haspath,linknodeno)
		
		if haspath~=nil then
			---有路线。
			---print("2:linknodeno,linknodeid",linknodeno,linknodeid)
				if linknodeno~=-999 then
						sql="update MUD_Links set linknodeno="..linknodeno	.." where nodeno=" ..nodeno.." and linknodeid='"..linknodeid.."'"
						DatabaseExec ("xkxalias_db",sql)
						DatabaseFinalize ("xkxalias_db")
						sql="update MUD_Links set path='"..path.."' where nodeno=" ..nodeno.." and linknodeno="..linknodeno
				else
						sql="update MUD_Links set path='"..path.."' where nodeno=" ..nodeno.." and linknodeid='"..linknodeid.."'"
				end
		else
			---路线未查到
				sql="insert into MUD_Links (nodeno,linknodeno,path,linknodeid) VALUES("..nodeno..","..linknodeno..",'"..path.."','"..linknodeid.."')"
		end
 ----- print(sql)
  DatabaseExec ("xkxalias_db",sql)
  DatabaseFinalize ("xkxalias_db")
end

function NewNode(inputNodeId)
-- put some data into the database
				if inputNodeId==nil or inputNodeId=="" then inputNodeId='-1' end
				local nodeno
				local sql
				
				local result = utils.umsgbox ( "是否录入该新节点？", "新节点","yesno","?")
				if result=="no" then return end
				local nodeid = utils.inputbox ( "【录入该节点ID】：（拼音全称，如yangzhou。若输入-1则视为放弃录入。）", "节点编辑", inputNodeId, nil, nil,INPUT_TABLE_SETTINGS)
				if nodeid=="-1" or nodeid==nil then 
						print(":放弃录入此节点入库:")
						return
				end
				local zonestr = utils.inputbox ( "录入该新节点[ "..nodeid.." ]所在【区域】：", "节点编辑", nodeid, nil, nil,INPUT_TABLE_SETTINGS)
				if zonestr==nil or zonestr=="" then zonestr=""	end
				local s_id = utils.inputbox ( "录入该新节点[ "..nodeid.." ]【简写代码】：", "节点编辑", nodeid, nil, nil,INPUT_TABLE_SETTINGS)
				if s_id==nil or s_id=="" then s_id=nodeid	end
		----------------------------------------------------------------------------------------------------------------------------------------------------			
					local tmp_nodeno=get_NodeNo(nodeid)
					---print("tmp_nodeno",tmp_nodeno)
					if tmp_nodeno==-999 then
								nodeno=get_Nodenocount()-----***********************
								sql="INSERT INTO MUD_Node (nodeno,relation,nodename,description,exits,zone,nodeid,s_id) VALUES ("..nodeno..",'"..R.relation.."','"..R.roomname.."','"..R.description.."','"..R.exits.."','"..zonestr.."','"..nodeid.."','"..s_id.."')"
					else
							local	hasnode = utils.umsgbox ( "该新节点[ "..nodeid.." ]为数据库已有节点，是否将此地房间信息覆盖库内信息？。", "节点录制","yesno","?")
							if hasnode=="yes"	then
								nodeno=tmp_nodeno
								sql="UPDATE MUD_Node SET relation='"..R.relation.."',nodename='"..R.roomname.."',description='"..R.description.."',exits='"..R.exits.."',zone='"..zonestr.."',nodeid='"..nodeid.."',s_id='"..s_id.."'	WHERE nodeno="..tmp_nodeno
							else
							end
					end---if tmp_nodeno
	----------------------------------------------------------------------------------------------------------------------------------------------------
				local linknodeid=""
				local tonodepath=""
				local	haslinknode = utils.umsgbox ( "【是否】录入该新节点[ "..nodeid.." ]的子节点？", "子节点录制","yesno","?")
				
				if haslinknode=="yes" then
					while true do
							linknodeid = utils.inputbox ( "请输入节点[ "..nodeid.." ]【子节点的ID】：（如，yangzhou。输入-1则放弃编辑）", "节点编辑", "-1", nil, nil,INPUT_TABLE_SETTINGS)
							if linknodeid=="-1"  or  linknodeid=="" then break end
							linknodeno=get_NodeNo(linknodeid)
							tonodepath = utils.inputbox ( "输入从节点[【"..nodeid.."】到子节点【"..linknodeid.."】的【路线】：", "路线编辑", "-1", nil, nil,INPUT_TABLE_SETTINGS)
							if tonodepath=="-1" or tonodepath==""	 then break end
							 insert_newpath(nodeno,linknodeno,tonodepath,linknodeid)
					end--while
				else
					print("::未给新节点:",nodeid,":加入新的子节点！")
				end---if haslinknode
	----------------------------------------------------------------------------------------------------------------------------------------------------

			
			  print("::NewNode_Recording::..........")
			  DatabaseExec ("xkxalias_db",sql)
			  DatabaseFinalize ("xkxalias_db")

			  print("::NewNode_Recording::......OKOK!")
			  pathlib_table,simplified_name=Output_Table_fromLib()
  return	nodeno
end

function RecordHere()
				   local _R
				   _R=Room.new()
				   _R.CatchEnd=function()
					 count,nodeno=Locate()
					 print("room_nums::",count)
					 --if count==0 then --new room
						-----print("1548:")---debug
						nodeno[1]=NewNode()
					 --end
					 --if count==1 then
					--		print("当前房间号[",nodeno[1],"]->在数据库里已经存在，无需重复录制。<-")
					--			local	haslinknode = utils.umsgbox ( "【是否】编辑该节点[ "..nodeid.." ]信息？", "节点编辑","yesno","?")
					--			if haslinknode=="yes"	then EditNode()	end								
					-- end

					--if count>1 then
					--		utils.umsgbox ( "::[:mapper:]此地信息在库内存在多个对应节点符合匹配！！::", "定位错误！")						
					--end

				   end
				   _R:CatchStart()
end
----***********************************************************************************
mapper_recordhere=function()
    RecordHere()
end
AddAlias("mapper_recordhere","#rec","",alias_flag.Enabled + alias_flag.Replace,"mapper_recordhere")

function get_nodename(nodeno)
----给出nodeno对应房间名。
	local _rname="未命名"
	local _rid=-999
	local _sid=-999
	local zonestr=""
	if nodeno==nil or nodeno==-999 then 
			return _rname,_rid,_sid
	end
	
     local sql="SELECT nodename, zone,nodeid,s_id from MUD_Node where nodeno="..nodeno
   -- prepare a query

    local rp=DatabasePrepare ("xkxalias_db", sql)
	local rc = DatabaseStep ("xkxalias_db")
	
   while rc == 100 do
				 values = DatabaseColumnValues ("xkxalias_db")
					_rname=values[1]
					zonestr=values[2]
					_rid=values[3]
					_sid=values[4]
				 rc = DatabaseStep ("xkxalias_db")  -- read next row
   end -- while loop
   
   DatabaseFinalize ("xkxalias_db")
   return _rname,_rid,_sid,zonestr
end

function get_Linknodeno_list(nodeno_list)
     sql="select * from MUD_Links where "
   for _,r in ipairs(nodeno_list) do
      sql = sql .."nodeno="..r.." "
   end
----	print("sql",sql)
   DatabasePrepare ("xkxalias_db", sql)
   local db_res={}
   local result={}
   local linknodeid_list={}
    rc = DatabaseStep ("xkxalias_db")
    while rc == 100 do
      values = DatabaseColumnValues ("xkxalias_db")
	  ----values[1]=nodeno,values[2]=linknodeno,values[3]=path,values[4]=linknodeid
      table.insert(db_res,values)
      rc = DatabaseStep ("xkxalias_db")  -- read next row
    end -- while loop
	----tprint(db_res)
	DatabaseFinalize ("xkxalias_db")
		if db_res~=nil and db_res~="" then
					for k,v in pairs(db_res) do
							---------------------------------------------------------------
							local cur_linknode_no=v[2]
							local cur_path=v[3]
							local cur_linknode_id=v[4]
							----print("1：cur_linknode_no,cur_path,cur_linknode_id::",cur_linknode_no,cur_path,cur_linknode_id)
							if cur_linknode_no==-999 then
								cur_linknode_no,cur_linknode_name=get_NodeNo(cur_linknode_id)----由linknodeid找--->linknodeno
								---print("2：cur_linknode_no,cur_linknode_name",cur_linknode_no,cur_linknode_name)
									if cur_linknode_no~=-999 and cur_linknode_no~=nil  and cur_linknode_no~="" then
									sql="update MUD_Links set linknodeno="..cur_linknode_no	.." where nodeno=" ..v[1].." and linknodeid='"..cur_linknode_id.."'"
									DatabaseExec ("xkxalias_db",sql)
									DatabaseFinalize ("xkxalias_db")								
									print("update linknodeno!!")
									end
							end---if v[2]
							---------------------------------------------------------------
							local c_name,c_id,c_sid=get_nodename(v[1])
							local n_name,n_id,n_sid=get_nodename(cur_linknode_no)
							---print(c_sid,n_sid)
							local haspath="有路线记录"
							if cur_path=="" or cur_path==nil then haspath="无路线记录" end
						 --print("当前节点:【"..c_name.."("..c_id..","..c_sid..")】["..v[1].."]","=>>第["..k.."]子节点：【"..n_name.."("..cur_linknode_id..","..n_sid..")】["..cur_linknode_no.."]","路线：【"..cur_path.."】。")
						 table.insert(result,v[2])
						 table.insert(linknodeid_list,v[3])
					end--for
		end--if
		
		
		
   return result,linknodeid_list
end

----***********************************************************************************
function EditNode()
				   local _R
				   _R=Room.new()
				   _R.CatchEnd=function()
						count,nodeno=Locate()
							--------------------------------------------------------
							if count==0 then --new room
								local	_editnode_yesno = utils.umsgbox ( "库内未查询到该节点，【是否】将此地录制入库？", "新节点录制","yesno","?")
								if _editnode_yesno=="yes"	then
										nodeno[1]=NewNode()
								else
								utils.umsgbox ( "放弃将此地作为新节点录制入库。", "节点录制")
								end
							end
							--------------------------------------------------------
							if count>1 then
								print("找到多个房间：")
								for k,v in pairs(nodeno) do
									local c_name,c_id,c_sid = get_nodename(v)
									print(k,v,c_id)
								end	
								k = tonumber(utils.inputbox("::[:mapper:]此地信息在库内存在多个对应节点符合匹配！！::，请对照列表输入序号：", "：节点选择：",-1, nil, nil,INPUT_TABLE_SETTINGS))
								count = 1
								nodeno = {nodeno[k]}
							end							
							if count==1 then
										
										local c_name,c_id,c_sid,c_zone=get_nodename(nodeno[1])
										local tmp_nodeno=nodeno[1]-----***********************
										------对当前节点编辑Links表：由nodeno[1]找到对应的nodelinksno，一个一个修改。一对多。
										-------print("当前节点【"..c_name.."】("..c_id..")[",nodeno[1],"]")

					-------************************************************************************************************************************************************************
											local	_edityesno = utils.umsgbox ( "【是否编辑】查询到对应节点信息，对此地[ "..c_id.." ]进行编辑吗？", "节点编辑","yesno","?")
											if _edityesno=="yes" then
														nodeid=c_id	
														local tmp_nodeid= utils.inputbox ( "【编辑节点ID】该节点[ "..c_id.." ]节点ID：", "节点编辑", c_id, nil, nil,INPUT_TABLE_SETTINGS)
														if tmp_nodeid~=nil and tmp_nodeid~="" then ----欲修改本节点ID.
																nodeid=tmp_nodeid
																tmp_nodeno=get_NodeNo(nodeid)
														end														
											else
														 utils.umsgbox ( "::放弃对此地[ "..c_id.." ]进行编辑！", "节点编辑")
														 return
											end
											
											local zonestr = utils.inputbox ( "【编辑区域】该节点[ "..nodeid.." ]所在区域】：", "节点编辑", c_zone, nil, nil,INPUT_TABLE_SETTINGS)
											if zonestr==nil or zonestr=="" then zonestr=""	end
											local s_id = utils.inputbox ( "【编辑简写代码】该节点[ "..nodeid.." ]简写代码：", "节点编辑", c_sid, nil, nil,INPUT_TABLE_SETTINGS)
											if s_id==nil or s_id=="" then s_id=nodeid	end
									----------------------------------------------------------------------------------------------------------------------------------------------------			
											if tmp_nodeno==nodeno[1] then
														sql="UPDATE MUD_Node SET zone='"..zonestr.."',nodeid='"..nodeid.."',s_id='"..s_id.."' WHERE nodeno="..tmp_nodeno
											else
														sql="UPDATE MUD_Node SET relation='"..R.relation.."',nodename='"..R.roomname.."',description='"..R.description.."',exits='"..R.exits.."',zone='"..zonestr.."',nodeid='"..nodeid.."',s_id='"..s_id.."' WHERE nodeno="..tmp_nodeno
											end
											print("::"..sql.."::")
											DatabaseExec ("xkxalias_db",sql)
											DatabaseFinalize ("xkxalias_db")
											pathlib_table,simplified_name=Output_Table_fromLib()
					-------************************************************************************************************************************************************************
									local curlinknolist,curlinkidlist=get_Linknodeno_list(nodeno)
									local cur_linknode_list={}
									   for i=1,#curlinknolist do
											local _t={}
													_t.number=i
													_t.name,_t.nodeid=get_nodename(curlinknolist[i])
													table.insert(cur_linknode_list,"【".._t.name.."】(".._t.nodeid..")")													
									   end--for i=1
									   if table_is_empty(cur_linknode_list)~=true then
												local linkspath
												while true do
															local _rlink = utils.listbox ("当前节点名称：【"..c_name.."】ID：("..c_id..")】编号：["..nodeno[1].."]，  子节点列表：", "：节点编辑：",cur_linknode_list)
															------print(_rlink)
															if _rlink==nil then print("[:mapper:]【放弃编辑节点】！");return end
															local linknodeno=curlinknolist[_rlink]
															local linknodeid=curlinkidlist[_rlink]
															-----print("linknodeno,linknodeid==>>",linknodeno,linknodeid)
															if linknodeno==-999 then
																	linknodeno=get_NodeNo(linknodeid)
															end
																	linkspath=get_Linkspath(nodeno[1],linknodeno,linknodeid)
															
															if linkspath==nil then linkspath="nothing" end
															local linknode_name,linknode_id,linknode_sid=get_nodename(linknodeno)
															-----------------------------------------------------------------------------------------------------------
															local	_delete_Linkpath_yesno = utils.umsgbox ( "【是否删除】当前节点【"..c_name.."】ID：("..c_id..")】到子节点【"..linknode_name.."】ID：("..linknode_id..")】的路线（MUD_Links）？", "删除路线","yesno","?")
															if _delete_Linkpath_yesno =="no" then 
															------------------------------------------------------------------------------------------------------------
																			local input_path=Trim( utils.inputbox ( "【请录入路线】当前节点【"..c_name.."】ID：("..c_id..")】到子节点【"..linknode_name.."】ID：("..linknode_id..")】的路线：", "：路线编辑：", linkspath, nil, nil,INPUT_TABLE_SETTINGS))

																			if input_path ~=nil and Trim(input_path)~="" then
																						insert_newpath(nodeno[1],linknodeno,input_path,linknodeid)
																					print("录入路线....OK!")
																					pathlib_table,simplified_name=Output_Table_fromLib()
																			end
															else
																			delete_Linkspath(nodeno[1],linknodeno,linknodeid)
																			print("::删除路线::..........OK!")
																			pathlib_table,simplified_name=Output_Table_fromLib()
																			
															end---if delete_Linkspath
															------------------------------------------------------------------------------------------------------------
															local	_editLinknode_yesno = utils.umsgbox ( "【是否继续录入】子节点？", "子节点录制","yesno","?")
															if _editLinknode_yesno =="no" then 
																	utils.umsgbox ( "::【您已终止】子节点录制！::", "子节点录制")
																	break 
															end
												end--while
									else
											---- table_is_empty==true
											local	_editLinknode_yesno = utils.umsgbox ( "此地不存在关联节点，【是否】按新节点录制此地信息？", "节点录制","yesno","?")
															if _editLinknode_yesno =="yes" then 
																	NewNode(c_id)
															else
															utils.umsgbox ( "::您已终止将节点按新节点录制！::", "节点录制")
															end
									end--if		 table_is_empty				   
								 end---count=1

								-- if count>1 then
									-- utils.umsgbox ( "::[:mapper:]此地信息在库内存在多个对应节点符合匹配！！::", "定位错误！")
								-- end

				   end
				   _R:CatchStart()
end
----***********************************************************************************
mapper_editlinks=function()
    EditNode()
end
AddAlias("mapper_editlinks","#edit","",alias_flag.Enabled + alias_flag.Replace,"mapper_editlinks")
----***********************************************************************************
mapper_getsid=function(n,l,w)
	local g_nodeno
	local g_nodename
	local g_nodesid
	local g_nodeid
	if  Trim(w[1])~=nil and Trim(w[1])=="all" then
			local nlist,slist=Output_Table_fromLib()
			Output_notepad(nlist,slist)
			return
	elseif Trim(w[1])~=nil and Trim(w[1])~="" then
			g_nodeid=Trim(w[1])
	else
		print("[:Error:]...输入的ID为空...\r\n格式：#sid nodeid。\r\n")
	end
			print("\r\n::查询ID::[",Trim(w[1]),"]\r\n")
			g_nodeno,g_nodename,g_nodesid=get_NodeNo(g_nodeid)
			if g_nodeno~=-999 then
						print("[::Search::]查询结果："," 房间名：["..g_nodename,"]  房间简码：["..g_nodesid,"]  房间号：["..g_nodeno.."]\r\n\r\n")
			else
						print("[::Search::]查询结果：未找到对应节点信息。\r\n\r\n")
			end
end
AddAlias("mapper_getsid","#sid (.*)","",alias_flag.Enabled + alias_flag.Replace + alias_flag.RegularExpression,"mapper_getsid")
----***********************************************************************************

function AddLinknode()
	require "tprint"
				   local _R
				   _R=Room.new()
				   _R.CatchEnd=function()
								 count,nodeno=Locate()
								 --tprint(nodeno)
								 if count==0 then --new room
									-----print("1548:")---debug
 									local	_editnode_yesno = utils.umsgbox ( "库内未查询到该节点，【是否】将此地录制入库？", "新节点录制","yesno","?")
									if _editnode_yesno=="yes"	then
											nodeno[1]=NewNode()
									else
									  utils.umsgbox ( "放弃将此地作为新节点录制入库。", "节点录制")
									end
								 end
								if count>1 then
									print("找到多个房间：")
									for k,v in pairs(nodeno) do
										local c_name,c_id,c_sid = get_nodename(v)
										print(k,v,c_id)
									end										
									k = tonumber(utils.inputbox("::[:mapper:]此地信息在库内存在多个对应节点符合匹配！！::，请对照列表输入序号：", "：节点选择：",-1, nil, nil,INPUT_TABLE_SETTINGS))
									count = 1 
									nodeno = {nodeno[k]}
									--tprint(nodeno)
								end
								 if count==1 then
								 local c_name,c_id,c_sid=get_nodename(nodeno[1])
											while true do
														local _addnodeid=Trim( utils.inputbox ( "请录入当前节点【"..c_name.."】ID：("..c_id..")】下设的【子节点ID】：（输入-1则视为输入完毕。）", "：节点编辑：",-1, nil, nil,INPUT_TABLE_SETTINGS))
														if tonumber(_addnodeid)==-1 then break end
														local linknodeno=get_NodeNo(_addnodeid)
														insert_newpath(nodeno[1],linknodeno,_addnodeid,_addnodeid)--加入虚拟路线,通过EditNode修改
														tonodepath = utils.inputbox ( "输入从节点[【"..c_name.."】到子节点【".._addnodeid.."】的【路线】：", "路线编辑", "-1", nil, nil,INPUT_TABLE_SETTINGS)
														if tonodepath=="-1" or tonodepath==""	 then break end
														insert_newpath(nodeno[1],linknodeno,tonodepath,_addnodeid)
														print("[:mapper:]录入子节点......OK!！")
											end--while
											------------------------------------------------------
									--local	Editnode_yesno = utils.umsgbox ( "【是否】继续将此地【"..c_name.."】ID：("..c_id..")】信息进行编辑？", "节点编辑","yesno","?")
									--if	Editnode_yesno=="yes"	then
									--		print("[:mapper:]继续对此节点进行编辑...录入对应路线！")
									--		EditNode()
									--end---if Editnode_yesno
									pathlib_table,simplified_name=Output_Table_fromLib()
								 end----if
									

				   end
				   _R:CatchStart()
end
mapper_addLinknode=function()
    AddLinknode()
end
AddAlias("mapper_addLinknode","#add","",alias_flag.Enabled + alias_flag.Replace,"mapper_addLinknode")
----***********************************************************************************
function Deletenodeid(nodeid)
		local sql
		
		local _delete_yesno=utils.umsgbox ( "::是否删除节点【ID：("..nodeid..")】及其关联信息::?", "删除节点","yesno","?")
				nodenoid=Trim(nodeid)
				if _delete_yesno=="yes"	then 
					print("Deleteing ",nodeid,"......")
					sql="DELETE FROM MUD_Node WHERE nodeid ='"..nodeid.."'"
					DatabaseExec ("xkxalias_db",sql)
					DatabaseFinalize ("xkxalias_db")
					print("Delete ["..nodeid.."] FROM MUD_Node OK!!")

					sql="DELETE FROM MUD_Links WHERE linknodeid ='"..nodeid.."'"
					DatabaseExec ("xkxalias_db",sql)
					DatabaseFinalize ("xkxalias_db")
					print("Delete ["..nodeid.."] FROM MUD_Links OK!!")
					pathlib_table,simplified_name=Output_Table_fromLib()
					
		else
				utils.umsgbox ( "::【放弃删除】::", "删除节点")
		end--if yesno
		
end
mapper_deleteNode=function(n,l,w)
	if w[1]~=nil and w[1]~="" then
			local nodeid=Trim(w[1])
			Deletenodeid(nodeid)
	else
			print("Delete Node id 格式错误！")
	end
end
AddAlias("mapper_deleteNode","#del (.*)","",alias_flag.Enabled + alias_flag.Replace + alias_flag.RegularExpression,"mapper_deleteNode")
----***********************************************************************************
local function get_fullnodeID(nodeid)
---也许是MUD_Node表里没有的ID。但是Links表里有。
		local haslinknodeId=false
		local linknodeId = nil
		-- local _t,s_idlist=Output_Table_fromLib()
		-- for k,v in pairs(s_idlist) do
		-- ----print(k,v)
				-- if nodeid==k then
						-- linknodeId=k
						-- haslinknodeId=true
						-- break
				-- end
				-- if nodeid==v then 
						-- linknodeId=k
						-- haslinknodeId=true
						-- break
				-- end
		-- end--for
		
		require "tprint"
		DatabaseOpen("map", "pkuxkx_p2palias_v2016.db", 2)
		DatabasePrepare("map", string.format("SELECT `_rowid_`,* FROM `MUD_Node` WHERE 1=1 AND `nodeid` LIKE '%s' ORDER BY `_rowid_` ASC LIMIT 0, 50000;", nodeid))
		rc = DatabaseStep ("map")  -- read next row
		values = DatabaseColumnValues ("map")
		if values ~= nil then
			linknodeId = values[8]
		end
		DatabaseFinalize ("map")
		if linknodeId == nil then
			DatabasePrepare("map", string.format("SELECT `_rowid_`,* FROM `MUD_Node` WHERE 1=1 AND `s_id` LIKE '%s' ORDER BY `_rowid_` ASC LIMIT 0, 50000;", nodeid))
			rc = DatabaseStep ("map")  -- read next row
			values = DatabaseColumnValues ("map")
			if values ~= nil then
				linknodeId = values[8]
			end
		end
		DatabaseClose("map")
		if linknodeId == nil then
			linknodeId = nodeid
		end
		--print("FullID: "..linknodeId)
		
		return linknodeId
end
function Gotonode(linknodeId)
 --start_time = os.time()
 local linknodeId=get_fullnodeID(linknodeId)
 --print("getfullid时间："..os.time()-start_time.."秒")

		local _R
				   --start_time = os.time()
				   _R=Room.new()
				   --print("new时间："..os.time()-start_time.."秒")
				   _R.CatchEnd=function()
								 --start_time = os.time()
								 count,nodeno=Locate()
								 --print("定位时间："..os.time()-start_time.."秒")
								 if count==0 then --new room
									print("[:mapper:]..ERROR..你所在的房间为 非节点房间。此房间未在节点库中查到。")
									run("set no_more not_found")
									return
								 end
								 if count==1 then
										----print("???????!!!!!!!!!!!???????????????",nodeno[1],linknodeId)
										local c_name,c_id,c_sid=get_nodename(nodeno[1])
										path_strings=c_id..","..linknodeId
										print("::>>",path_strings,"<<::")
										do_walkgo(path_strings,walktime)
										
								 end

								if count>1 then
										print ( "::[:mapper:]此地信息在库内存在多个对应节点符合匹配！！::", "开始随机定位！")
										local t={}
										t=utils.split(exits,";")
										rN = math.random(1, table.getn(t))
										--do_walkgo(t[rN]..";",0.1)
										Execute(SetGanche..t[rN])
										run("set no_more rewalk")
										prev_cmd = "gt "..linknodeId
								end

				   end
				   _R:CatchStart()
		
end
mapper_gotonode=function(n,l,w)
            walkend_cmd = nil
			local linknodeId=Trim(w[1])
			if linknodeId==nil or linknodeId=="" then
					print(README_DOC)
			elseif linknodeId=="here"	then
					LocateHere()
			elseif linknodeId=="list"	then
				local nlist,slist=Output_Table_fromLib()
				Output_notepad(nlist,slist)
			else
				--goto_time = os.time()
				prev_cmd = w[0]
				Gotonode(linknodeId)
				--print("GT Time: "..os.time()-goto_time)
			end
end
mapper_gotonode2=function()
			print(README_DOC)
end
AddAlias("mapper_gotonode","gt (.*)","",alias_flag.Enabled + alias_flag.Replace	+ alias_flag.RegularExpression,"mapper_gotonode")
AddAlias("mapper_gotonode2","gt","",alias_flag.Enabled + alias_flag.Replace,"mapper_gotonode2")
----***********************************************************************************

----***********************************************************************************
function Load_NodeList_fromTable(pathlib_table)
		local tmp_nodeno=-999
		local nodeno=-999
		local relation=""
		local nodename=""
		local description=""
		local exits=""
		local zonestr=""
		local nodeid=""
		local HELP=[[
			["hhbeiwest"]={	--::>黄河西北<::--,简码：[>>hhxb<<]
									["NodeName"]="黄河西北",
									["ZoneName"]="黄河",
									["ZoneId"]="huanghe",
									["LinkNodes"]={
										["hhbeidukou1"]=	"e;#3 ne",
										},
								},		
		]]

		-----MUD_Node表输入：---->>>
		if table_is_empty(pathlib_table)==true then 
			print("::数据库表格无数据::")
			return
		end
		for k,v in pairs(pathlib_table) do
			nodeid=k
			nodename=v.NodeName
			zonestr=v.ZoneId
			------------------------------------------------------------------------------------------------------------------------------------------
			local tmp_nodeno=get_NodeNo(nodeid)
			
			if tmp_nodeno==-999 then
						nodeno=get_Nodenocount()
						sql="INSERT INTO MUD_Node (nodeno,relation,nodename,description,exits,zone,nodeid,s_id) VALUES ("..nodeno..",'"..relation.."','"..nodename.."','"..description.."','"..exits.."','"..zonestr.."','"..nodeid.."','"..nodeid.."')"
			else
						sql="UPDATE MUD_Node SET nodename='"..nodename.."',zone='"..zonestr.."',nodeid='"..nodeid.."',s_id='"..nodeid.."'	WHERE nodeno="..tmp_nodeno
			end
			
			  print("::NewNode_Recording::..........")
			  DatabaseExec ("xkxalias_db",sql)
			  DatabaseFinalize ("xkxalias_db")

			  print("::NewNode_Recording::......OKOK!")
		------------------------------------------------------------------------------------------------------------------------------------------
		end--for
		-----MUD_Node表输入：----<<<
		
		-----MUD_Links表输入：---->>>
		local tmp_linknodeno=-999
		local tmp_linknodeid=""
		local tmp_path=""
		for k,v in pairs(pathlib_table) do
				nodeid=k
				tmp_nodeno=get_NodeNo(nodeid)
				
				for k1,v1 in pairs(v.LinkNodes) do
							tmp_linknodeid=k1
							tmp_linknodeno=get_NodeNo(tmp_linknodeid)
							tmp_path=v1
							print("LinkNodes:::>>>>   ",tmp_nodeno,tmp_linknodeno,tmp_path,tmp_linknodeid)
							insert_newpath(tmp_nodeno,tmp_linknodeno,tmp_path,tmp_linknodeid)
				end--k1				
		end
		-----MUD_Links表输入：----<<<
		
end

function Output_Table_fromLib()
			local sql="SELECT * from MUD_Node"
			local sql1="SELECT * from MUD_Links"
			local mudNodelist={}
			local mudLinklist={}
			local pathlib_table={}
			local simplified_name={}
			local mudNodeId={}
			local HELP=[[
			["hhbeiwest"]={	--::>黄河西北<::--,简码：[>>hhxb<<]
									["NodeName"]="黄河西北",
									["ZoneName"]="黄河",
									["ZoneId"]="huanghe",
									["LinkNodes"]={
										["hhbeidukou1"]=	"e;#3 ne",
										},
								},		
		]]

	rp=DatabasePrepare("xkxalias_db",sql)
	rc=DatabaseStep("xkxalias_db")
	----print("get_Linkspath,sql,rc",sql,rc)
	if rc~=100 then
		utils.umsgbox ( "Database is ERROR!!!", "::ERROR::")
		-----return
	end
	while rc==100 do
				v=DatabaseColumnValues("xkxalias_db")			
			table.insert(mudNodelist,v)
				pathlib_table[v[7]]={}
				pathlib_table[v[7]]["Sim_ID"]=v[8]
				simplified_name[v[7]]=v[8]
				pathlib_table[v[7]]["NodeName"]=v[3]
				pathlib_table[v[7]]["ZoneId"]=v[6]
				pathlib_table[v[7]]["LinkNodes"]={}
				mudNodeId[v[1]] = v[7]
			rc=DatabaseStep("xkxalias_db")
	end--while 
	DatabaseFinalize("xkxalias_db")
	------tprint(mudNodelist)
	rp=DatabasePrepare("xkxalias_db",sql1)
	rc=DatabaseStep("xkxalias_db")
	----print("get_Linkspath,sql,rc",sql,rc)
	while rc==100 do
			values=DatabaseColumnValues("xkxalias_db")
			table.insert(mudLinklist,values)
			rc=DatabaseStep("xkxalias_db")
	end--while 
	DatabaseFinalize("xkxalias_db")
	---------------------------------------------
	
	-- for k,v in pairs(mudNodelist) do
		-- ------v[3]==nodename,v[7]==nodeid
				-- pathlib_table[v[7]]={}
				-- pathlib_table[v[7]]["Sim_ID"]=v[8]
				-- simplified_name[v[7]]=v[8]
				-- pathlib_table[v[7]]["NodeName"]=v[3]
				-- pathlib_table[v[7]]["ZoneId"]=v[6]
				-- pathlib_table[v[7]]["LinkNodes"]={}
				-- mudNodeId[v[1]] = v[7]
	-- end
	--print(mudNodeId[1])
	for k,v in pairs(mudLinklist) do
		------v[3]==nodename,v[7]==nodeid
		--local cur_name,cur_id,cur_sid=get_nodename(v[1])
		cur_id = mudNodeId[v[1]]
		if cur_id ~= nil then
			--print(v[1],	cur_id)
			cur_name = pathlib_table[cur_id]["NodeName"]
			cur_sid = pathlib_table[cur_id]["Sim_ID"]
			if cur_id == -999 then
			else
				local link_id=v[4]
				pathlib_table[cur_id]["LinkNodes"][link_id]=v[3]
				if pathlib_table[link_id]==nil then
					simplified_name[link_id]=link_id
				end
			end
		end
	end---for
	
	
			return pathlib_table,simplified_name,outputstring
			
end
function Output_notepad(pathlib_table,simplified_name)
	-- local outputstring="simplified_name={--::节点全称及简码对照表:: \r\n"
	local i=0
	-- for k,v in pairs(simplified_name) do
			-- i=i+1
			-- local _,_nodename=get_NodeNo(k)
			-- if math.fmod (i, 4)==0	then
				-- outstr="\r\n"
			-- else
				-- outstr=""
			-- end	
				-- outputstring=outputstring..'	["'..k..'"]="'..v..'",--[['.._nodename..']]'..outstr				
	-- end
	-- outputstring=outputstring..'\r\n	}\r\n\r\n'
	-- outputstring=outputstring.."--::全节点库对照表::\r\n\r\n\r\npathlib_table={  \r\n\r\n"
	outputstring = "::全节点库对照表::\r\n"
	-- for k,v in pairs(pathlib_table) do
				-- outputstring=outputstring..'	["'..k..'"]={\r\n'
				-- outputstring=outputstring..'				["Sim_ID"]="'..v["Sim_ID"]..'",\r\n'
				-- outputstring=outputstring..'				["NodeName"]="'..v["NodeName"]..'",\r\n'
				-- outputstring=outputstring..'				["ZoneId"]="'..v["ZoneId"]..'",\r\n'
				-- outputstring=outputstring..'				["LinkNodes"]={\r\n'
				-- for k1,v1 in pairs(v.LinkNodes) do
					-- outputstring=outputstring..'						["'..k1..'"]="'..v1..'",\r\n'
				-- end
				-- outputstring=outputstring..'							},\r\n}\r\n\r\n'
	-- end
	for k,v in pairs(pathlib_table) do
		if v["NodeName"] ~= "" then
			outputstring = outputstring.."["..v["ZoneId"]..v["NodeName"].."]=["..k.."]=["..v["Sim_ID"].."]\r\n"
		end
	end
	SendToNotepad("path_lib_table",outputstring)
end

function Load_simplified_name_fromTable(simplified_name)
	local help=[[
	simplified_name={----*********城市简码表 START***********************-------

	["hhbeiwest"]=	"hhxb",	["hhnanwest"]=	"hhxn",	["hhnandukou1"]=	"hhbdk",	["hhbeidukou1"]=	"hhndk",
	["hhnangudu"]=	"hhngd",	["hhbeigudu"]=	"hhbgd",	["mengjindu"]=	"mjd",	["fenglingdu"]=	"fld",
	["hhnandukou4"]=	"hhnd4",	["hhbeidukou4"]=	"hhbd4",	["hhbeieast"]=	"hhdb",	["hhnanruhaikou"]=	"hhrhk",
	["cjnanwest"]=	"ccxn",	["cjbeiwest"]=	"ccxb",	["lingji"]=	"lj",	["lingjin"]=	"ljin",
	}
	]]
		for k,v in pairs(simplified_name) do
				sql="UPDATE MUD_Node SET s_id='"..v.."' WHERE nodeid='"..k.."'"				
			  print("::SimID_Recording::..........OK!!",k,v)
			  DatabaseExec ("xkxalias_db",sql)
			  DatabaseFinalize ("xkxalias_db")
		end--for
	
end

function Load_NodeList_fromOLDTable(pathlib_table)
		local tmp_nodeno=-999
		local nodeno=-999
		local relation=""
		local nodename=""
		local description=""
		local exits=""
		local zonestr=""
		local nodeid=""
				local HELP=[[
				path_alias_table={
								["hhbeidukou4"]={
									["puyang"]="w;ne;nw",
									["hhnandukou4"]="yellboat",
									["hhbeieast"]="e;ne",
								},	
					}
		]]
		if table_is_empty(pathlib_table)==true then 
			print("::数据库表格无数据::")
			return
		end
		-----MUD_Node表输入：---->>>
			for k,v in pairs(pathlib_table) do
					nodeid=k
			------------------------------------------------------------------------------------------------------------------------------------------
					local tmp_nodeno=get_NodeNo(nodeid)
			
					if tmp_nodeno==-999 then
								nodeno=get_Nodenocount()
								sql="INSERT INTO MUD_Node (nodeno,relation,nodename,description,exits,zone,nodeid,s_id) VALUES ("..nodeno..",'"..relation.."','"..nodename.."','"..description.."','"..exits.."','"..zonestr.."','"..nodeid.."','"..nodeid.."')"
					else
								sql="UPDATE MUD_Node SET	nodeid='"..nodeid.."',s_id='"..nodeid.."'	WHERE nodeno="..tmp_nodeno
					end
					  print("::NewNode_UPDATE [MUD_Node]::..........")
					  DatabaseExec ("xkxalias_db",sql)
					  DatabaseFinalize ("xkxalias_db")

					  print("::NewNode_UPDATE [MUD_Node]::......OKOK!")
		------------------------------------------------------------------------------------------------------------------------------------------
				end--for
		-----MUD_Node表输入：----<<<
		
			
		-----MUD_Links表输入：---->>>
		local tmp_linknodeno=-999
		local tmp_linknodeid=""
		local tmp_path=""
		for k,v in pairs(pathlib_table) do
				nodeid=k
				tmp_nodeno=get_NodeNo(nodeid)
				
				for k1,v1 in pairs(v) do
							tmp_linknodeid=k1
							tmp_linknodeno=get_NodeNo(tmp_linknodeid)
							tmp_path=v1
							print("LinkNodes:::>>>>   ",tmp_nodeno,tmp_linknodeno,tmp_path,tmp_linknodeid)
							insert_newpath(tmp_nodeno,tmp_linknodeno,tmp_path,tmp_linknodeid)
				end--k1				
		end
		-----MUD_Links表输入：----<<<
		
		
end


----***********************************************************************************
----节点录制====THE	End===
----***********************************************************************************
----***********************************************************************************


print("Loading	pkuxkx_p2palias_v2016	WalkMode.....OK!!")
----**************************************************************************
pathlib_table,simplified_name=Output_Table_fromLib()
------Output_notepad(pathlib_table,simplified_name)
----**************************************************************************
walk={}
walkgo={}
pathlib={}
--Setkeyboardon=0
Set_Walkkeyshort=1----允许使用本插件默认快捷设定。如：赶车开关设定F9。
SetGanche=""----初始化
Set_wait_Interval=15----系统默认自动插入wait时间的步数，wait的时间是：wait_step_time。
wait_step=0		----若为0，按Set_wait_Interval步插入一条等待命令wait。
				----若为-1则不插入，关闭快速行走，开启慢速行走即每一步都等待walktime时间。
wait_step_time=100 -----系统自动插入的暂停时间间隔的毫秒。

walktime=0.1	--采用慢速行走后wait_step=-1，自定义每一步行走的间隔时间：默认为0.1秒。
				--注意：这里直接设定的是秒。

walk.gancheon=0	---赶车设置开关。开启赶车即默认开启慢速行走，关闭赶车状态即恢复快速行走。
				----默认非赶车状态。F9(或自定义设置的按键)每按动一次，开启或关闭赶车状态。
				----使用此设定需配合aliascmd.gancheon函数为宜。

INI_wait1000s_steps=1	--系统wait 1 s时相当于默认走的步数。wait的加权处理。
						--若设置较大，则会出现忽视带有wait的路线而选择乘船路线。
INI_yellboat_steps=20	--系统处于坐船状态时对应步数。坐船的加权处理。
						--若设置较大，则会出现忽视带有乘船的路线而选择有wait的路线。
						
qiangold=0    --是否给过钱眼开黄金
hgtongxing=0  --皇宫通行令是否起作用						

----**************************************************************************
------------------------------------------------------------------------------
-------特殊行走命令表----start----
----特殊命令必须有对应的trigger支持，以便处理相应触发。
----工作原理：见到特殊命令后，内部处理为这个命令加walk_wait(1)，来处理触发，walk_pause，然后触发再次walk_resume。
----不加对应触发，将在命令后加入wait 1 s，继续后续命令。
special_cmd={"climb","zou tiesuo","guo","yellboat","unwield","row"}
--special_cmd={"climb","zou tiesuo","guo","unwield","row"}
-------特殊行走命令表----End----

-----**************************************************************--------
-----******Alias模块*********开始**********************************--------
-----**************************************************************--------

aliascmd={}
aliascmd.update=function()

	addtri("walkgo_stepcmd",'^[> ]*设定环境变量：no_more = "walkgo"$',"system","walkgo.stepcmd")
	addtri("walkgo_blocker","^[> ]*(--哎哟，你一头撞在墙上，才发现这个方向没有出路。\\w*|你小心翼翼往前挪动，遇到艰险难行处，只好放慢脚步。\\w*|你还在山中跋涉，一时半会恐怕走不出\\w*|青海湖畔美不胜收，你不由停下脚步，欣赏起了风景。\\w*|你不小心被什么东西绊了一下\\w*|你的动作还没有完成，不能移动\\w*)","system","walkgo.blocker")

	addtri("sp_pause","^(>)*( )*(你踩上铁索，向山涧的对面飘然而去\\w*|你一咬牙，扳住崖上的岩石\\w*|你扶着铁索，踏上桥板\\w*)","system","do_walkstop")
	--addtri("sp_resume","^(>)*( )*(突然间蓬一声，屁股撞上了什么物事，\\w*)","system","do_walkresume")
	addtri("sp_home",'"^[> ]*\\s*.*\\.*≡━◎个人档案◎.+\\n\\n【.+】.*「.*」(.*)\\((.*)\\)"','home','alias_home')
	addtri("walkgo_busy","^(> )*你正忙$","walkbusy","checkbusy")
	addtri("walkgo_busy","^(> )*你不忙$","walkbusy","walk_busyover")
	addtri("walkgo_path_pause","^(> )*(你整了整衣服，走了进去。|你定了定神，走了出来。|你从下面爬了上来，衣服都烂了，看起来十分狼狈。|你从上面爬了下来，衣服都烂了，看起来十分狼狈。|六名雪山弟子一齐转动机关，吊桥便又升了起来。|大车停稳了下来，你可以下车\\(xia\\)了。|你身在半空，双手乱挥，只盼能抓到什么东西，这么乱挥一阵，又下堕下百馀丈。|你终于一步步的终于挨到了桥头\\.|你终于来到了对面，心里的石头终于落地。|你听到声音的来源好象是从左侧\\(left\\)的墙壁\\(wall\\)中发出的。|你在左侧墙上的一块石缝中摸到了一处开关\\(button\\)。)$","path_pause",walk_resume)
---------------------------------------------
---------------------------------------------
	SetTriggerOption("walkgo_stepcmd","omit_from_output",1)
		SetTriggerOption("sp_home","multi_line",1)
		SetTriggerOption("sp_home","lines_to_match",3)

	EnableTrigger("walkgo_stepcmd",1)
	EnableTrigger("walkgo_blocker",1)
	EnableTrigger("sp_pause",1)
	EnableTrigger("sp_resume",1)


	yellboat.update()
	print("walk_alias 更新完毕!")

end

aliascmd.cmd=function(n,l,w)
	yellboat.inboat=0
	yellboat.special=0
	---

	walkalias=aliascmd.format(Trim(w[1]))

	if walkalias==nil or string.len(Trim(walkalias))==0 then
		walkalias="Error"
		--print("::"..walkalias.."::")
		return
	end
	print("::"..walkalias.."::")
	if walktime==0 or walktime==nil or wait_step==0 then walktime=0.1 end

	do_walkgo(walkalias,walktime)
end

aliascmd.format=function(fstring)
--	if string.find (fstring, "go")~=nil then
--		fstring=string.gsub(fstring,"go","-")
--	end
	if string.find (fstring, ",")~=nil then
		fstring=string.gsub(fstring,",","-")
	end
	if string.find (fstring, "-")~=nil then
		t_str_tb=utils.split (fstring, "-")
		first_str=aliascmd.fullname(t_str_tb[1])
		last_str=aliascmd.fullname(t_str_tb[2])

		if not checkNodelist(first_str) or not checkNodelist(last_str) then
				Note("::开始或结束城市输入有误，或地图库中没有此中心城市::")
				return
		end

		aliasstr=first_str.."-"..last_str
	elseif string.find (fstring, ";")~=nil then

		aliasstr=fstring
	else
		first_str="yangzhou"
		last_str=aliascmd.fullname(fstring)
		aliasstr=first_str.."-"..last_str
	end
	return aliasstr
end

aliascmd.fullname=function(namestr)
	for fullstr,normalstr in pairs(simplified_name) do
		if normalstr==namestr then
			return fullstr
		end
	end
	return namestr
end
--------------2010.12.26-------------
aliascmd.walkquickon=function()
	Note("::开启快速行走，系统将每隔20步（或设定值）插入1秒（或设定值）的暂停::")
	walktime = 0.3
	wait_step=0
end

aliascmd.walkquickoff=function()
	Note("::关闭快速行走，系统将按每步数间隔时间设定值，在每步插入相应的暂停时间::")
	walktime = 0.01
	wait_step=-1
end

aliascmd.gancheon=function()
		Note("::开启赶车状态，注意小键盘已经被设置为赶车快捷键！")
		SetGanche="gan che to "
        walktime = 2
		walk.gancheon=1
		wait_step=-1---同时设置为慢速行走。
	aliascmd.keyshort()
end

aliascmd.gancheoff=function()
		Note("::关闭赶车状态，注意小键盘已经被设置为行走快捷键！")
		SetGanche=""
        walktime = 0.3
		walk.gancheon=0
		wait_step=0---同时设置为快速行走。
	aliascmd.keyshort()
end

-------------------------------------
aliascmd.fullpath=function(n,l,w)

_fullstr=aliascmd.format(w[1])
if _fullstr==nil or _fullstr==" " then
		print("你没有这个搜索路线。")
		return---2011.10.12
	end
local p_str,_steps,f_tb=convert_path(_fullstr)

	if wait_step==0 then
		local full_str,ff_steps=pathstr_t(f_tb)
		f_steps=searchpath.distance(ff_steps)---------11.07.26
	else
		full_str,f_steps=p_str,_steps
	end

print("::".._fullstr.."::")
Note("查询路线步数："..f_steps)
Note("对应路线：["..p_str.."]")
SetVariable("fullpath", p_str)
end
----2010.12.6--11.55
alias_walk_busy=function(n,l,w)
				walk_busy(Trim(w[1]))
end
alias_ganche_avoid=function(n,l,w)
				ganche_avoid(Trim(w[1]))
end
alias_path_pause=function(n,l,w)
				path_pause(Trim(w[1]))
end
alias_home=function(n,l,w)
			SetVariable("myname",Trim(w[1]))
			SetVariable("myid",string.lower(Trim(w[2])))
			Note(w[1],w[2])
			go_home()
end
home=function(n,l,w)
	EnableTriggerGroup("home",1)
    DoAfterSpecial(1,'run("sc")',12)
end
go_home=function(n,l,w)
	if GetVariable("inv_id")~=nil and GetVariable("inv_id")~=0 then
		print("进"..GetVariable("inv_name").."的"..GetVariable("inv_address").."房间，id是："..GetVariable("inv_id"))
		DoAfterSpecial(1,'Execute("enter "..GetVariable("inv_id"))',12)
	else
		print("进"..GetVariable("myname").."的房间，id是："..GetVariable("myid"))
		DoAfterSpecial(1,'Execute("enter "..GetVariable("myid"))',12)
		DoAfterSpecial(2,'Execute("find") EnableTriggerGroup("home",0)',12)	
	end
end
function	alias_room_skip_lb(n,l,w)
			Execute(Trim(w[1]))
end
-----------------------------------------------
	AddAlias("alias_walk_busy","^walk_busy\\((.*)\\)","",alias_flag.Enabled + alias_flag.Replace + alias_flag.RegularExpression,"alias_walk_busy")
	AddAlias("alias_path_pause","^path_pause\\((.*)\\)","",alias_flag.Enabled + alias_flag.Replace + alias_flag.RegularExpression,"alias_path_pause")
	AddAlias("alias_path_home","^home\\((.*)\\)","",alias_flag.Enabled + alias_flag.Replace + alias_flag.RegularExpression,"home")
	AddAlias("alias_roomskip","^room_skip\\((.*)\\)$","",alias_flag.Enabled + alias_flag.Replace + alias_flag.RegularExpression,"alias_room_skip_lb")
-----**************************************************************--------
-----******Alias模块*********结束**********************************--------
-----**************************************************************--------

-----**************************************************************--------
-----******行走模块**********开始**********************************--------
-----**************************************************************--------

walkgo["ok"]=nil
walkgo["fail"]=nil
steps_table={}
do_walkgo=function(path_strings,wktime,walkgo_ok,walkgo_fail)

	walkgo["ok"]=walkgo_ok
	walkgo["fail"]=walkgo_fail
	steps_table={}
	walkgo["path"]=aliascmd.format(path_strings)
	walkgo["stepwait"]=wktime
	call(walkgo.main)
	---go_walk(path_strings,wktime)
end
----******************************************************************************************
function walkgo:new()
    local wl={}
	setmetatable(wl, {__index = walkgo})
    return wl
end
----******************************************************************************************
walkgo["main"]=function()

	walk_step_count=1
	need_wait_time=0.1
	walk.needstop=0
	walk.meetblocker=0
	walk.needwait=0
	step_maxn=1

	if walkgo["stepwait"]==nil or tonumber(walkgo["stepwait"])<=0.1 then
	walkgo["stepwait"]=0.1
	end

	------------------------------------------------------------------------------------------------------------------------
	start_time = os.clock()
	fullpath_str,c_steps,final_tb=convert_path(walkgo["path"])
	--print("搜索用时："..os.clock()-start_time.."秒")

	if fullpath_str==nil or fullpath_str==" " or fullpath_str=="l" or fullpath_str=="look" then
		walk_time=0.1
		print("[:walk:]::ERROR::没有搜索到相应路线。")
		run("set no_more walkend")
		SetEchoInput(true)
		return
	end

	if wait_step==0 then----快速行走状态，需要15步插入一个wait
	steps_table,real_steps=pathstr_t(final_tb)---插入walk_wait()
	fullpath_steps=searchpath.distance(real_steps)---------11.07.26
	else
	steps_table,real_steps=final_tb,c_steps
	fullpath_steps=table.getn(final_tb)------11.09.24
	end
	----------------------------------------
		step_maxn = table.getn(steps_table)
	----------------------------------------
	if fullpath_str~=nil then
		print("当前行走步数："..fullpath_steps)
		print("路线为::>>"..fullpath_str.."<<::")
		SetEchoInput(false)
		call(walkgo.cmd)
	end

end

walkgo.cmd=function(wtime)
	if wtime==nil then wtime=0.1 end
	DoAfterSpecial(wtime,'run("set no_more walkgo")',12)
end--walkgo.cmd

walk_step_count=1

walkgo["stepcmd"]=function()

	----***************************************************
	if walk.needstop==1 then
		if walk_step_count==0 or walk_step_count==nil then walk_step_count=1 end
		print("=::>Mannual Stop Walk!::<==")
		walk.needstop=0
		return
	end

	if walk.meetblocker==1 then
		--print("=::>Meet Blocker Pause Walk!::<==")
		walk_step_count = walk_step_count -1
		if walk_step_count==0 or walk_step_count==nil then walk_step_count=1 end
	end
	----***************************************************

	----***************************************************
	if walk_step_count<=step_maxn then
        SetVariable("walk_step_count", walk_step_count)
        SetVariable("step_maxn", step_maxn)
		command_str=steps_table[walk_step_count]
	else
        SetVariable("walk_step_count", walk_step_count)
        SetVariable("step_maxn", step_maxn)
		fullpath_str=""
		EnableTriggerGroup("boat",0)
		print("完成行走！！")
		run("set no_more walkend")
		SetEchoInput(true)
		if walkend_cmd ~= nil then
			Execute(walkend_cmd)
			walkend_cmd=nil
		end
		steps_table={}
		walk_step_count=1
		walkgo["walkend"]("ok")
		return
	end

		if SetGanche==nil then 
			SetGanche=""  
		end
        if command_str ~= nil then
			if string.len(SetGanche)~=0 and SetGanche~=nil and string.find (command_str,"walk_wait")==nil and string.find (command_str,"walk_busy")==nil then
				if Ganche_dir(steps_table[walk_step_count]) == "yellboat" then
					command_str=Ganche_dir(steps_table[walk_step_count])
				else
					command_str=SetGanche..Ganche_dir(steps_table[walk_step_count])
				end
			end
		else 
			SetVariable("walk_step_count", walk_step_count)
			SetVariable("step_maxn", step_maxn)
			fullpath_str=""
			EnableTriggerGroup("boat",0)
			print("完成行走！！")
			run("set no_more walkend")
			SetEchoInput(true)
			if walkend_cmd ~= nil then
			  Execute(walkend_cmd)
			  walkend_cmd=nil
			end
			steps_table={}
			walk_step_count=1
			walkgo["walkend"]("ok")
			return
		end

		--if command_str==nil then command_str="" end ----2011.10.29 update
	--------------------------------------------------------
		if string.find (command_str,"walk_wait")~=nil then
			loadstring(command_str)();
			if walk_step_count<=step_maxn then
			walkgo.cmd(need_wait_time)
			end
				--DoAfterSpecial(need_wait_time,'run("set no_more walkgo")',12)
		else
			if string.find(command_str,"unwield all") and (string.len(SetGanche)~=0 and SetGanche~=nil) then
				--print(SetGanche)
				Execute("unwield all")
			else
				if walk.meetblocker==1 then
					walk.meetblocker=0
					command_str = "halt;"..command_str
				end
				Execute(command_str)
			end
			if walk_step_count<=step_maxn then
				walkgo.cmd(walkgo["stepwait"])
			end
			---DoAfterSpecial(walkgo["stepwait"],'run("set no_more walkgo")',12)
		end
	----------------------------------------------
	walk_step_count = walk_step_count +1
	----------------------------------------------
	--------------------------------------------------------
end

walkgo["walkend"]=function(s)
	if ((s~="")and(s~=nil)) then
		call(walkgo[s])
	else
		walkgo["ok"]=nil
		walkgo["fail"]=nil
	end

end


walkgo_end_ok=function()
	if walk.gancheon==1 then aliascmd.gancheon() end
	walkgo["walkend"]("ok")
end

walkgo_end_fail=function()
	walkgo["walkend"]("fail")
end
----******************************************************************************************
----******************************************************************************************
-------------------------------------
walkgo.blocker=function()
	walk.meetblocker=1
	walk.needstop=0
	---print("::meetblocker::")---debug
end

Ganche_dir=function(sim_dir)

local n = string.len (sim_dir)*1
	if n<=2 then
	sim_dir=string.gsub(sim_dir,"u","up",1)
	sim_dir=string.gsub(sim_dir,"s","south",1)
	sim_dir=string.gsub(sim_dir,"n","north",1)
	sim_dir=string.gsub(sim_dir,"e","east",1)
	sim_dir=string.gsub(sim_dir,"w","west",1)
	sim_dir=string.gsub(sim_dir,"d","down",1)
		end
	return sim_dir
end
----------------------------------------
function checkbusy()
	EnableTriggerGroup("walkbusy",0)
    DoAfterSpecial(1,'EnableTriggerGroup("walkbusy",1)\nrun("checkbusy")',12)
end
function walk_busy(str)
	if SetGanche~=nil then
		Execute(SetGanche..Ganche_dir(str))
	else
		EnableTriggerGroup("walkbusy",1)
		walk_pause()
		Execute("h;"..str)
		DoAfterSpecial(1,'run("checkbusy")',12)
	end
end
function ganche_avoid(str)
	if SetGanche~=nil then
		Execute(SetGanche..Ganche_dir(str))
	else
		Execute(str)
	end
end
function walk_busyover()
	EnableTriggerGroup("walkbusy",0)
	walk_resume()
end
function path_pause(str)
	EnableTriggerGroup("path_pause",1)
	walk_pause()
	Execute(str)
end

function walk_pause()
	walk.needstop=1
	if city.aim ~= nil then
	  SetVariable("gt_end",city.aim)
	end
	SetVariable("prev_cmd", prev_cmd)
	print("======= Walk Pause!!======")
	SetEchoInput(true)
	--DeleteTemporaryTimers()
	if  walk_step_count == nil then walk_step_count=2 end
end

function walk_wait(s)
	walk.needwait=1
	if fullpath_str ==nil then
			print("=====没有搜索路径!!=====")
			return
	end
	if s==nil or s*1<=0.1 then
	need_wait_time=0.1
	print("===Wait...".. 0.1 .." seconds continue===")
	else
	need_wait_time=s
	print("===Wait..."..s.." seconds continue===")
	end
end

function walk_resume()
DeleteTemporaryTimers()
print("======= Walk resume!!======")
SetEchoInput(false)
	walk.needstop=0
	EnableTriggerGroup("path_pause",0)
	if fullpath_str ~=nil and walk_step_count <= step_maxn and walk_step_count~=0 then
	  walk_auto_next();
	else
		run("set no_more walkend")
		SetEchoInput(true)
		if walkend_cmd ~= nil then
			Execute(walkend_cmd)
			walkend_cmd=nil
		end
	  print("=====已经到达终点或没有搜索路径!!=====")
	end
end

function walk_auto_next()
	--run("set no_more walkgo")
	ResetTimer("walkgo")
	AddTimer("walkgo",0,0,0.1,'SendNoEcho("set no_more walkgo")',5,"")
	SetTimerOption("walkgo","send_to",12)
end
do_walkstop=function()
	call(walk_pause)
end
do_walkresume=function()
	call(walk_resume)
end
do_walkcontinue=function()
	Execute(prev_cmd)
end
do_walkallstop=function()
	print("==Walk All Stop,Don't Use AutoWalk!!==")
	print("==Walk Mode is quickwalking now!!==")
	DeleteTemporaryTimers()
	unhookall()
	wait_step=0
end

-----****************************************************----
-----****************************************************----
walk_on_room=function(name, line, wildcards)
	if #wildcards[1]~=0 then
		_roomname=wildcards[1]
	end
	SetVariable("roomname",_roomname)
end

walk_on_room1=function(name, line, wildcards)
	if #wildcards[1]~=0 then
		_roomname=wildcards[1]
	end
	SetVariable("roomname1",_roomname)
end

-----**************************************************************--------
-----******行走模块**********结束**********************************--------
-----**************************************************************--------

-----**************************************************************--------
-----******行船模块 ***********开始********************************--------
-----**************************************************************--------
yellboat={}
yellboat.inboat=0
yellboat.comeboat=0
yellboat.count=0
yellboat.givedone=0


yellboat.main=function()

	walk_pause()
	EnableGroup("boat",1)
	run("look")
	DoAfterSpecial(0.2,"yellboat.cmd()",12)
end


yellboat.cmd=function()
	yellboat.count=yellboat.count+1
	run("ask shao gong about 过河;ask shao gong about 过江;yell boat")
	call(yellboat.enterboat)
	run("enter boat")
end
yellboat.boatcoming=function()
	yellboat.comeboat=1
	call(yellboat.enterboat)
end
yellboat.enterboat=function()
	run("halt;"..SetGanche.."enter")
	if yellboat.comeboat==1 then
	  run(SetGanche.."enter")
	else
	  DoAfterSpecial(2,"yellboat.yellcmd()",12)
	end
end
yellboat.yellcmd=function()
	---delay(2,run,"yell boat")
	run("yell boat")
end

yellboat.wait=function()
	yellboat.inboat=0
	--delay(2,run,"yell boat")
	DoAfterSpecial(2,"yell boat",10)
end

------------------------------------------
yellboat.over=function()
	EnableGroup("boat",0)
	Execute("halt;"..SetGanche.."out")
	yellboat.comeboat=0
	yellboat.inboat=0
	yellboat.count=0
	call(walk_resume)
end
yellboat.endok=function()
	yellboat.comeboat=0
	yellboat.inboat=0
	yellboat.count=0
	call(walk_resume)
end

yellboat.inboatok=function()
walk_pause()
	yellboat.inboat=1
	yellboat.comeboat=1
	yellboat.givedone=1
end
yellboat.needmoney=function()
	yellboat.givedone=0
	if yellboat.count>3 then
	  Note("是不是没带钱啊？==:::wait 3 seconds yell again:::==")
	  ---delay(3,yellboat.yellcmd)
	else
	  DoAfterSpecial(0.2,"yellboat.cmd()",12)
	  return
	end
end
yellboat.hasgive=function()
	yellboat.givedone=1
end
yellboat.update=function()

	addtri("yb_needmoney","^(>)*( )*艄公一把拉住你，\\w*","boat","yellboat.needmoney")
	addtri("yb_wait",'^(>)*( )*(你吸了口气，一声“船家”\\w*|你使出吃奶的力气\\w*|你没事不要乱往别人船上钻!\\w*)',"boat","yellboat.wait")
	addtri("yb_come","^(>)*( )*(一叶扁舟缓缓地驶了过来，艄公将一块踏脚板.+|岸边一只渡船上的老艄公说道：正等着你.+)","boat","yellboat.boatcoming")

	addtri("yb_over","^(>)*( )*(艄公说“到啦，上岸吧”.+|船夫对你说道：“到了\\w*|你朝船夫挥了挥手.+|小舟终于划到近岸.+|.+你跨上岸去。\\w*|不知过了多久，船终于靠岸了，你累得满头大汗。\\w*)","boat","yellboat.over")
	addtri("yb_inboat",'^(>)*( )*(艄公把踏脚板收起来\\w*|船夫把踏脚板收起来\\w*|小舟在湖中藕菱之间的水路\\w*|你跃上小舟，船就划了起来。\\w*|你拿起船桨用力划了起来。\\w*)',"boat","yellboat.inboatok")


	AddAlias("alias_yellboat","yellboat","",alias_flag.Enabled + alias_flag.Replace ,"yellboat.main")

	SetAliasOption("alias_yellboat","group","path");
end
-----**************************************************************--------
-----******行船模块 ***********结束********************************--------
-----**************************************************************--------

-----**************************************************************--------
-----******行走函数 ***********开始********************************--------
-----**************************************************************--------

-----***************************************************************************
function decomp_string(decom_str)
----作用：分解zmud嵌套复合串，返回简单复合串。
----参数：decom_str：嵌套复合串
----	（如:	没有“-”(1)fuzhou;e;w;e。(2)fuzhou;(3)fuzhoub;
----			有“-”(1)kz-yz;s;s;w。(2)e;e;n;yz-fzh(3)kz-yz）
----返回值：处理后的简单复合串。如：#5 e;e;w;eu;ed;#3 n
temp_decomp_table={}
hasindir=1
data_string=decom_str
output_str=""
output_str_tb={}

		if string.find (data_string, "#")~=nil then
							output_str=data_string
		--end
		else
			if string.find (data_string, ";")~=nil then
				temp_dec=utils.split (data_string,";")
					for k,v in pairs(temp_dec) do
						if string.find (v, "-")~=nil then
							output_str=output_str..decomp_string(v)..";"
						else
							if type(pathlib_table[v])~="table" then
							output_str=output_str..v..";"
							end
						end

					end
					output_str=rtrim(";",output_str)
			else

					if string.find (data_string, "-")~=nil then
					temp_dec=utils.split (data_string, "-")
					_startcity=aliascmd.fullname(temp_dec[1])
					_aimcity=aliascmd.fullname(temp_dec[2])

						if checkNodelist(_startcity)==false or checkNodelist(_aimcity)==false then
							output_str="l"
							Note(":::没有这个开始点或结束点城市:::")
						else

							_searchpath=searchpath.search(_startcity,_aimcity)
							if _searchpath==nil then _searchpath="l" end
							output_str=output_str.._searchpath..";"
						end
					else
					----------------------------------------------------------------
						if string.sub (data_string, -1)=="b" then
							first_str=aliascmd.fullname(rtrim("b",data_string))
								if pathlib_table[first_str]~=nil then
									_startcity=first_str
									_aimcity="yangzhou"
									_searchpath=searchpath.search(_startcity,_aimcity)

									if _searchpath==nil then _searchpath="l" end
									output_str=output_str.._searchpath..";"
								end
						else

							_startcity="yangzhou"
							_aimcity=data_string

								_searchpath=searchpath.search(_startcity,_aimcity)
								if _searchpath==nil then _searchpath="l" end
							output_str=output_str.._searchpath..";"
						end
						----------------------------------------------------------------

					----------------------------------------------------------------

					end
				output_str=rtrim(";",output_str)
			end
		end
	output_str_tb=utils.split(output_str,";")

	return output_str,output_str_tb
		-----------------------------------------------------------
		----11.07.26--End
		-----------------------------------------------------------
end--function
-----***************************************************************************

temp_slow_path_table={}
final_path_table={}
compound=1
function convert_path(path_name)
--作用：将复合串转化为单纯串。即由复合zmud alias串，转化为单一命令的alias串。
--参数：path_name，字符串，三种形式：
--		1、单纯的复合串；如：#5 e;n;nu;e
--		2、嵌套复合串；如：fuzhou;n;e;nu;e，或kz-fzh;n;e;e，或kz-hyd形式。
--返回值：
----1、分解后的简单复合串，全常规alias，把fuzhou;e;e;#5 e;--->#4 nu;#3 e;e;n形式
----2、解析后单纯串表的步数，解析后的单纯串，解析后单纯串对应步数。--未加入wait_time时步数。
----3、分解为单存串后对应的表格：#5 e;s;e--->e;e;e;e;e;s;e对应的表格。
----4、返回的单存串，#5 e;s;e---->e;e;e;e;e;s;e这个串。
----工作原理：
----	1）先分解嵌套复合串为简单复合串。
----	2）判断简单复合串表内个元素状态。
----	3）整合返回值。返回串未加入walk_wait函数。

	---if compound==1 and wait_step==0 then------2011.10.01 debug slowwalk

		if compound==1 then
			temp_fullpath_str,temp_slow_path_table=decomp_string(path_name)
			--print(temp_fullpath_str)
		else

			temp_fullpath_str=path_name
			temp_slow_path_table=utils.split (path_name, ";")
			compound=1
		end

if temp_fullpath_str==nil then return nil end

	local i,v =1, table.maxn(temp_slow_path_table)*1
	while i<=v do

		normal_cmd=1

		for key,value in pairs(special_cmd) do
			if temp_slow_path_table[i]==value then normal_cmd=0 end
		end
		if normal_cmd==0 then
			temp_slow_path_table[i]=temp_slow_path_table[i]..";walk_wait(0.1)"
			i=i+1
		else

			if string.find (temp_slow_path_table[i], "#[wW][aA]")~=nil then
				s_time=string.match (temp_slow_path_table[i], "[0-9]+", 1)
				--s_time=math.ceil(s_time/1000)
                                s_time=s_time/1000
				if s_time<=0.1 or s_time==nil then
				s_time=0.1
				end
				temp_slow_path_table[i]="walk_wait("..s_time..")"
				i=i+1
			else
				if string.sub (temp_slow_path_table[i], 0, 1)~="#" then
					i=i+1
				else
					n = string.match (temp_slow_path_table[i], "[1-9][0-9]?", 1)
					str = Trim(string.gsub(temp_slow_path_table[i],"[()#%d]?",""))
					str = Trim(string.gsub(str,"do",""))
					str_path=""
				for j=1,n do
					str_path=str_path..str..";"
				end
					temp_slow_path_table[i]=rtrim(";",str_path)
					i=i+1
				end
			end
		end
	end
	temp_path_string=table.concat(temp_slow_path_table,";")
	final_path_table=utils.split (temp_path_string, ";")
	maxsteps=table.maxn(final_path_table)

	return temp_fullpath_str,maxsteps,final_path_table,temp_path_string

end


pathstr_t=function(str_table)
----输入路线表格，返回按要求插入#wa 1000后的表。
----系统自动加入#wa 1000功能函数，可根据设置自行添加。
	if wait_step ==0 then wait_Interval =Set_wait_Interval end
	if wait_step==-1 then return str_table end
	if wait_step_time~=nil and wait_step_time~=0 then
		--w_time=math.ceil(wait_step_time/1000)
                w_time=wait_step_time/1000
	else
		w_time=1
	end
	str_ins="walk_wait("..w_time..")"
	str_line=""
	str_count=0
	temp_str_table={}
	for k,v in pairs(str_table) do
		if string.sub (v, 1, 2)~="wa" then
			str_line=str_line..v..";"
			str_count=str_count+1
			normal_cmd = 1
			for key,value in pairs(special_cmd) do
				if temp_slow_path_table[i]==value then normal_cmd=0 end
			end
			if str_count>=wait_Interval and string.find(v,"room_skip")==nil and normal_cmd == 1 then
				str_line=rtrim(";",str_line)
			 	table.insert(temp_str_table,str_line)
			 	table.insert(temp_str_table,str_ins)
				str_count=0
				str_line=""
			end
		else
			if #str_line ~= 0 then
				str_line=rtrim(";",str_line)
				table.insert(temp_str_table,str_line)
				str_count=0
				str_line=""
			end
				table.insert(temp_str_table,v)
		end
	end
	if #str_line~= 0 then
		str_line=rtrim(";",str_line)
		table.insert(temp_str_table,str_line)
	end
	temp_addwait_str=table.concat(temp_str_table,";")

	return temp_str_table,temp_addwait_str
end

----两中心城市，点对点城际快速路函数。-----------------------

searchpath={}
city={}

searchpath.distance=function(dis_string)
--作用：计算单纯串的步数。
--参数要求：dis_string，单纯串，不考虑系统自行加入的walk_wait(1)这步。
--返回值：fullsteps，单纯串的步数。

--过程：向单纯串按要求插入walk_wait()，然后处理插入后的字符串。

compound=0

	--print("------debug-----")
	_,_,real_steps_table=convert_path(dis_string)
	fullsteps=0
	s_distance=0
real_cursteps={}
------------------------------------------
local i,v =1, table.maxn(real_steps_table)*1

	while i<=v do

		if string.sub (real_steps_table[i], 1, 4)=="yell" then
				real_cursteps[i]=INI_yellboat_steps

		elseif string.sub (real_steps_table[i], 1, 9)=="walk_wait" then

				str_wait_time=string.match (real_steps_table[i], "[0-9]+", 1)
				real_cursteps[i]=str_wait_time*INI_wait1000s_steps
		elseif string.sub (real_steps_table[i], 1, 2)=="gu" then
			real_cursteps[i]=5
		elseif string.sub (real_steps_table[i], 1, 9)=="walk_busy" and (SetGanche == nil or SetGanche == "") then
		  real_cursteps[i]=30
		elseif string.find(real_steps_table[i], "ganche_avoid") and SetGanche~= nil and SetGanche~= "" then
		  real_cursteps[i]=9999999
		else
				real_cursteps[i]=1
		end
		fullsteps=fullsteps+real_cursteps[i]

		i=i+1
	end--while
------------------------------------------
------------------------------------------
	return fullsteps
end

---************************************************************************************
---************************************************************************************
RouteINI=100000000
searchpath.search2=function(startcity,aimcity)
		city.start=startcity
		city.aim=aimcity
		visited={}
		precity={}
		dist={}
		needvisit={}
		curdist={}
		city.start_list={city.start}
		newdis=0

		-- for cityname,path in pairs(pathlib_table) do
			-- visited[cityname]=0
			-- precity[cityname]=""
			-- dist[cityname]=RouteINI*1
			-- curdist[cityname]=RouteINI*1
		-- end

-------------------------------------------------------
	if type(pathlib_table[city.start])=="string" then
		_str_s=pathlib_table[city.start]
		bestpath,bestdist=convert_path(_str_s)
		return bestpath,bestdist
	end
	if type(pathlib_table[city.start])~="table" then
		startcity="yangzhou"
		city.start=startcity
	end
-------------------------------------------------------

		neednext=true
		iteration = 0
		prestart = 0
		precitydist =0 
		start_time = os.clock()
		while neednext do
		neednext=false
			--start_time = os.time()
			iteration = iteration + 1
			for i = 1, table.getn(city.start_list) do
				city.start = city.start_list[i]
				--print("city.start"..iteration.." =",city.start)
				if pathlib_table[city.start] ~= nil then
				for kNode,vRoute in pairs(pathlib_table[city.start]["LinkNodes"]) do
					--print(kNode,vRoute)
					if (string.find(vRoute,"gu")~=nil or string.find(vRoute,"dong")~=nil) and SetGanche~="" then
					else
						table.insert(needvisit,kNode)
					end
                ------------------------------------------------------------------

					-- if precity[city.start]~=nil and precity[city.start]~="" then
						-- _,prestart=searchpath.getpath(startcity,city.start)
						-- else
						-- prestart=0
					-- end
                ---------------------------------------------------------------
					--tprint(precity)
					-- if precity[kNode]~=nil then
						-- _,precitydist=searchpath.getpath(startcity,precity[kNode])
					-- else
						-- precitydist=0
					-- end
					--local newdis=searchpath.distance(vRoute)

					if (string.find(vRoute,"gu")~=nil or string.find(vRoute,"dong")~=nil or string.find(vRoute,"hole")~=nil) and SetGanche~="" then
					else
					-- if (dist[kNode]==nil or dist[kNode]==RouteINI or prestart*1+newdis*1 <precitydist+dist[kNode]*1) then
					if precity[kNode] == nil then
						dist[kNode]=newdis*1
						precity[kNode]=city.start
						curdist[kNode]=newdis*1+prestart*1
					end
					end
					--------------------------------------------------------------

					--if visited[kNode]==nil then visited[kNode]=0 end
					if kNode == city.aim then 
						neednext = false
						--tprint(precity)
						--print(startcity,city.aim)
						bpath,bdist=searchpath.getpath(startcity,city.aim)
						print("搜索用时："..os.clock()-start_time.."秒")
						return bpath,bdist
					else
						--print(kNode, iteration)
						neednext = true
					end

				end--- 
				end
			end
			city.start_list = needvisit
			needvisit = {}
			--print(os.time() - start_time)
			visited[city.start]=1

			-- mincurdist=RouteINI
			-- --tprint(needvisit)
			-- --tprint(pathlib_table[city.start]["LinkNodes"])
			-- --start_time = os.time()
			-- for key,value in pairs(needvisit) do
				-- if visited[value]==nil then visited[value]=0 end

				-- if type(pathlib_table[value])~="table" then
					-- visited[value]=1
				-- end

				-- if visited[value]==0 then
					-- neednext=true
					-- if curdist[value]*1 < mincurdist*1 then
						-- mincurdist=curdist[value]*1
						-- city.start=value
						-- removepos=key*1
					-- end
				-- end
				-- if visited[city.aim]==1 then
					-- bpath,bdist=searchpath.getpath(startcity,city.aim)
					-- print(iteration)
				-- --if (string.find(bpath,"gu")~=nil or string.find(bpath,"enter shudong")~=nil) and SetGanche~="" then
					-- return bpath,bdist
				-- --else
				-- --	neednext = true
				-- --end
				-- end
			-- end		----for needvisit
			-- --print(os.time() - start_time)
			-- table.remove(needvisit,removepos)
			-- --tprint(needvisit)
			-- --print(startcity.." "..city.aim)
			-- --tprint(visited)
			-- if visited[city.aim]==1 then
				-- bpath,bdist=searchpath.getpath(startcity,city.aim)
				-- print(iteration)
				-- --if (string.find(bpath,"gu")~=nil or string.find(bpath,"enter shudong")~=nil) and SetGanche~="" then
					-- return bpath,bdist
				-- --else
				-- --	neednext = true
				-- --end
			-- end
		
		end--------while

str_p=""
findaim=0
bestdist=0

	-- if visited[city.aim]==1 then
        -- bpath,bdist=searchpath.getpath(startcity,city.aim)		
        -- return bpath,bdist
	-- else
		-- return nil
	-- end
end ---searchpath
searchpath.search=function(startcity,aimcity)
		city.start=startcity
		city.aim=aimcity
		visited={}
		precity={}
		dist={}
		needvisit={}
		curdist={}
		newdis=0
		--start_time = os.clock()
		for cityname,path in pairs(pathlib_table) do
			visited[cityname]=0
			precity[cityname]=""
			dist[cityname]=RouteINI*1
			curdist[cityname]=RouteINI*1
		end
		--print(os.clock()-start_time)

-------------------------------------------------------
	if type(pathlib_table[city.start])=="string" then
		_str_s=pathlib_table[city.start]
		bestpath,bestdist=convert_path(_str_s)
		return bestpath,bestdist
	end
	if type(pathlib_table[city.start])~="table" then
		startcity="yangzhou"
		city.start=startcity
	end
-------------------------------------------------------

		neednext=true
		iteration = 0
		start_time = os.clock()
		while neednext do
		neednext=false
			--start_time = os.time()
			iteration = iteration + 1
			for kNode,vRoute in pairs(pathlib_table[city.start]["LinkNodes"]) do
				--print(kNode,vRoute)
				if (string.find(vRoute,"gu")~=nil or string.find(vRoute,"dong")~=nil) and SetGanche~="" then
				else
					table.insert(needvisit,kNode)
				end
                ------------------------------------------------------------------

                if precity[city.start]~=nil and precity[city.start]~="" then

                    _,prestart=searchpath.getpath(startcity,city.start)
                    else
                    prestart=0
                end
                ---------------------------------------------------------------
				if precity[kNode]~=nil then
					_,precitydist=searchpath.getpath(startcity,precity[kNode])
				else
					precitydist=0
				end
				local newdis=searchpath.distance(vRoute)

				if (string.find(vRoute,"gu")~=nil or string.find(vRoute,"dong")~=nil or string.find(vRoute,"hole")~=nil) and SetGanche~="" then
				else
					if (dist[kNode]==nil or dist[kNode]==RouteINI or prestart*1+newdis*1 <precitydist+dist[kNode]*1) then
						dist[kNode]=newdis*1
						precity[kNode]=city.start
						curdist[kNode]=newdis*1+prestart*1
					end
				end
					--------------------------------------------------------------

				if visited[kNode]==nil then visited[kNode]=0 end

			end--- for
			--print(os.time() - start_time)
			visited[city.start]=1

			mincurdist=RouteINI
			--tprint(needvisit)
			--tprint(pathlib_table[city.start]["LinkNodes"])
			--start_time = os.time()
			for key,value in pairs(needvisit) do
				if visited[value]==nil then visited[value]=0 end

				if type(pathlib_table[value])~="table" then
					visited[value]=1
				end

				if visited[value]==0 then
					neednext=true
					if curdist[value]*1 < mincurdist*1 then
						mincurdist=curdist[value]*1
						city.start=value
						removepos=key*1
					end
				end
				-- if visited[city.aim]==1 then
					-- bpath,bdist=searchpath.getpath(startcity,city.aim)
					-- print(iteration)
				-- --if (string.find(bpath,"gu")~=nil or string.find(bpath,"enter shudong")~=nil) and SetGanche~="" then
					-- return bpath,bdist
				--else
				--	neednext = true
				--end
				-- end
			end		----for needvisit
			--print(os.time() - start_time)
			table.remove(needvisit,removepos)
			--tprint(needvisit)
			--print(startcity.." "..city.aim)
			--tprint(visited)
			if visited[city.aim]==1 then
				bpath,bdist=searchpath.getpath(startcity,city.aim)
				if nodebugging == nil then
				  print("搜索用时："..os.clock()-start_time.."秒")
				end
				--print(iteration)
				--if (string.find(bpath,"gu")~=nil or string.find(bpath,"enter shudong")~=nil) and SetGanche~="" then
					return bpath,bdist
				--else
				--	neednext = true
				--end
			end
		
		end--------while

str_p=""
findaim=0
bestdist=0

	-- if visited[city.aim]==1 then
        -- bpath,bdist=searchpath.getpath(startcity,city.aim)		
        -- return bpath,bdist
	-- else
		-- return nil
	-- end
end ---searchpath

searchpath.search1=function(startcity,aimcity)
		city.start=startcity
		city.aim=aimcity
		visited={}
		precity={}
		dist={}
		needvisit={}
		curdist={}
		newdis=0

		for cityname,path in pairs(pathlib_table) do
			visited[cityname]=0
			precity[cityname]=""
			dist[cityname]=RouteINI*1
			curdist[cityname]=RouteINI*1
		end

-------------------------------------------------------
	if type(pathlib_table[city.start])=="string" then
		_str_s=pathlib_table[city.start]
		bestpath,bestdist=convert_path(_str_s)
		return bestpath,bestdist
	end
	if type(pathlib_table[city.start])~="table" then
		startcity="yangzhou"
		city.start=startcity
	end
-------------------------------------------------------

		neednext=true
		iteration = 0
		start_time = os.clock()
		needvisit={city.start}
		mincurdist=RouteINI
		visited[city.start]=1
		prestart=0
		precitydist=0
		neednext = true
		while neednext do
			--start_time = os.time()
			--table.remove(needvisit,city.start)
			iteration = iteration + 1
			for kNode,vRoute in pairs(pathlib_table[city.start]["LinkNodes"]) do
				--print(kNode,vRoute)
				if (string.find(vRoute,"gu")~=nil or string.find(vRoute,"dong")~=nil) and SetGanche~="" then
				elseif visited[kNode] == nil then
					table.insert(needvisit,kNode)
                ------------------------------------------------------------------
					--local newdis=searchpath.distance(vRoute)
					local newdis = 1

					if (string.find(vRoute,"gu")~=nil or string.find(vRoute,"dong")~=nil or string.find(vRoute,"hole")~=nil) and SetGanche~="" then
					else
						if (dist[kNode]==nil or dist[kNode]==RouteINI or prestart*1+newdis*1 <precitydist+dist[kNode]*1) then
							dist[kNode]=newdis*1
							precity[kNode]=city.start
							curdist[kNode]=newdis*1+prestart*1
						end
					end
					--------------------------------------------------------------
					visited[kNode] = 1
					if visited[city.aim]==1 then
						--bpath,bdist=searchpath.getpath(startcity,city.aim)
						neednext=false
						print("搜索用时："..os.clock()-start_time.."秒")
						return bpath,bdist
					end
					if curdist[value]*1 < mincurdist*1 then
						mincurdist=curdist[value]*1
						city.start=kNode
					end
				end
				--if visited[kNode]==nil then visited[kNode]=0 end

			end--- for
			--print(os.time() - start_time)
			-- visited[city.start]=1

			-- mincurdist=RouteINI
			--tprint(needvisit)
			--tprint(pathlib_table[city.start]["LinkNodes"])
			--start_time = os.time()
			-- for key,value in pairs(needvisit) do
				-- if visited[value]==nil then visited[value]=0 end

				-- if type(pathlib_table[value])~="table" then
					-- visited[value]=1
				-- end

				-- if visited[value]==0 then
					-- neednext=true
					-- if curdist[value]*1 < mincurdist*1 then
						-- mincurdist=curdist[value]*1
						-- city.start=value
						-- removepos=key*1
					-- end
				-- end
				-- if visited[city.aim]==1 then
					-- bpath,bdist=searchpath.getpath(startcity,city.aim)
					-- print(iteration)
				-- --if (string.find(bpath,"gu")~=nil or string.find(bpath,"enter shudong")~=nil) and SetGanche~="" then
					-- return bpath,bdist
				--else
				--	neednext = true
				--end
				-- end
			-- end		----for needvisit
			-- --print(os.time() - start_time)
			-- table.remove(needvisit,removepos)
			-- --tprint(needvisit)
			-- --print(startcity.." "..city.aim)
			-- --tprint(visited)
			-- if visited[city.aim]==1 then
				-- bpath,bdist=searchpath.getpath(startcity,city.aim)
				-- print("搜索用时："..os.clock()-start_time.."秒")
				-- --print(iteration)
				-- --if (string.find(bpath,"gu")~=nil or string.find(bpath,"enter shudong")~=nil) and SetGanche~="" then
					-- return bpath,bdist
				-- --else
				-- --	neednext = true
				-- --end
			-- end
		
		end--------while

str_p=""
findaim=0
bestdist=0

	-- if visited[city.aim]==1 then
        -- bpath,bdist=searchpath.getpath(startcity,city.aim)		
        -- return bpath,bdist
	-- else
		-- return nil
	-- end
end ---searchpath
---************************************************************************************
---************************************************************************************

searchpath.getpath=function(fromcity,tocity)
_tocity=tocity
_fromcity=fromcity
str_p=""
findaim=0
bestdist=0
--tprint(precity)
	if _fromcity==_tocity then
	-----print("searchpath.getpath:目的地和起始地一样::")
		bestpath=nil
		bestdist=0
		return bestpath,bestdist
	end

	if precity[_tocity]==nil or precity[_tocity]=="" then
		-----print("searchpath.getpath::无路线记录!::")
		_fromcity=_tocity
		bestpath="l"
		bestdist=0
		findaim=1
		return bestpath,bestdist
	end
	i = 0
	 --print(precity[_tocity])
	 --print(_tocity)
	 --print(pathlib_table[precity[_tocity]]["LinkNodes"][_tocity])
	--for i = 1,iteration do
	while findaim==0 do
				--print(precity[_tocity],_tocity)
				path=pathlib_table[precity[_tocity]]["LinkNodes"][_tocity]
				--print(path)
				str_p=path..";"..str_p
				bestdist=bestdist+dist[_tocity]

			if precity[_tocity]~=_fromcity then
				_tocity=precity[_tocity]
				findaim=0
			else
				findaim=1
			end--if

	end--while
	
	bestpath=rtrim(";",str_p)
	if bestpath==nil or bestdist==nil then
		bestpath="l"
		bestdist=0
	end

	return bestpath,bestdist
end

function checkNodelist(key)

		if key==nil then return false end

		allNode={}
		for k,v in pairs(pathlib_table) do
			allNode[k]=1
			for m,n in pairs(v.LinkNodes) do
			allNode[m]=1
			end
		end

        if allNode[key]==1 then
                return true
        else
                return false
        end
end

function checkNodeisTable(key)

		if key==nil or not checkNodelist(key) then return false end

		if type(pathlib_table[key])=="table" then
				return true
        else
                return false
        end
end


-----**************************************************************--------
-----******行走函数 ***********结束********************************--------
-----**************************************************************--------


----AddAlias("alias_update","/alupdate","",alias_flag.Enabled + alias_flag.Replace + alias_flag.RegularExpression,"aliascmd.update")
AddAlias("alias_path","^(\\w+[-,]\\w+[^:])$","",alias_flag.Enabled + alias_flag.Replace + alias_flag.RegularExpression,"aliascmd.cmd")
AddAlias("alias_walkstop","wks","",alias_flag.Enabled + alias_flag.Replace,"do_walkstop")
AddAlias("alias_walkgo","wkg","",alias_flag.Enabled + alias_flag.Replace,"do_walkresume")
AddAlias("alias_walkquickon","quickon","",alias_flag.Enabled + alias_flag.Replace,"aliascmd.walkquickon")
AddAlias("alias_walkallstop","wkallstop","",alias_flag.Enabled + alias_flag.Replace,"do_walkallstop")

AddAlias("aliascmd_gancheon","gancheon","",alias_flag.Enabled + alias_flag.Replace,"aliascmd.gancheon")
AddAlias("alias_fullpath","fullpath (\\w+[-,]\\w+[^:])$","",alias_flag.Enabled + alias_flag.Replace + alias_flag.RegularExpression,"aliascmd.fullpath")

SetAliasOption("alias_walkallstop","group","path");
SetAliasOption("alias_path","group","path");
SetAliasOption("alias_walkstop","group","path");
SetAliasOption("alias_walkgo","group","path");
SetAliasOption("alias_walkquickon","group","path");
SetAliasOption("aliascmd_gancheon","group","path");
SetAliasOption("alias_fullpath","group","path");

SetAliasOption("alias_walkback","group","path");

----*******************************************************
--Set_F9_act="gancheon"
----Accelerator("F9",Set_F9_act)----"F9"
----*******************************************************
aliascmd.keyshort=function()

-----------------------------------------------------
Set_F8_act=""
Set_F9_act="gancheon"


Set_F10_act=""
Set_F11_act=""
Set_F12_act=""
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------

Set_Numpad1="southwest"
Set_Numpad2="south"
Set_Numpad3="southeast"
Set_Numpad4="west"
Set_Numpad5="look"
Set_Numpad6="east"
Set_Numpad7="northwest"
Set_Numpad8="north"
Set_Numpad9="northeast"

SetCtr_Numpad1="westdown"	---"Ctr+Num1"
SetCtr_Numpad7="westup"		---"Ctr+Num7"

SetCtr_Numpad4="enter"		---"Ctr+Num4"
SetCtr_Numpad5="localmaps"	---"Ctr+Num5"
SetCtr_Numpad6="out"		---"Ctr+Num6"

SetCtr_Numpad8="up"			---"Ctr+Num8"
SetCtr_Numpad2="down"		---"Ctr+Num2"

SetCtr_Numpad9="eastup"		---"Ctr+Num9"
SetCtr_Numpad3="eastdown"	---"Ctr+Num3"

SetCtr_Numpad0="southup"	---"Ctr+Num0"
SetCtr_Del="southdown"		---" Ctr+ . "


SetCtr_Mul="northdown"		---" Ctr+ * "
SetCtr_Div="northup"		---" Ctr+/ "
---------------------------------------------------------------------------------



		Accelerator("Numpad1",SetGanche..Set_Numpad1)----“1”
		Accelerator("Numpad2",SetGanche..Set_Numpad2)----“2”
		Accelerator("Numpad3",SetGanche..Set_Numpad3)----“3”
		Accelerator("Numpad4",SetGanche..Set_Numpad4)----“4”
		Accelerator("Numpad5",Set_Numpad5)----“5”
		Accelerator("Numpad6",SetGanche..Set_Numpad6)----“6”
		Accelerator("Numpad7",SetGanche..Set_Numpad7)----“7”
		Accelerator("Numpad8",SetGanche..Set_Numpad8)----“8”
		Accelerator("Numpad9",SetGanche..Set_Numpad9)----“9”

		Accelerator("F8",Set_F8_act)----"F8"
		Accelerator("F9",Set_F9_act)----"F9"
		Accelerator("F10",Set_F10_act)----"F10"
		Accelerator("F11",Set_F11_act)----"F11"
		Accelerator("F12",Set_F12_act)----"F12"

		Accelerator("Ctrl+Numpad0",SetGanche..SetCtr_Numpad0)----“Ctrl+0”
		Accelerator("Ctrl+Numpad1",SetGanche..SetCtr_Numpad1)----“Ctrl+1”
		Accelerator("Ctrl+Numpad2",SetGanche..SetCtr_Numpad2)----“Ctrl+2”
		Accelerator("Ctrl+Numpad3",SetGanche..SetCtr_Numpad3)----“Ctrl+3”
		Accelerator("Ctrl+Numpad4",SetGanche..SetCtr_Numpad4)----“Ctrl+4”
		Accelerator("Ctrl+Numpad5",SetGanche..SetCtr_Numpad5)----“Ctrl+5”
		Accelerator("Ctrl+Numpad6",SetGanche..SetCtr_Numpad6)----“Ctrl+6”
		Accelerator("Ctrl+Numpad7",SetGanche..SetCtr_Numpad7)----“Ctrl+7”
		Accelerator("Ctrl+Numpad8",SetGanche..SetCtr_Numpad8)----“Ctrl+8”
		Accelerator("Ctrl+Numpad9",SetGanche..SetCtr_Numpad9)----“Ctrl+9”
		Accelerator("Ctrl+Decimal",SetGanche..SetCtr_Del)----“Ctrl+del”
		Accelerator("Ctrl+Multiply",SetGanche..SetCtr_Mul)----“Ctrl+*”
		Accelerator("Ctrl+Divide",SetGanche..SetCtr_Div)---“Ctrl+/”

end
if Set_Walkkeyshort==1	then
aliascmd.keyshort()
end
aliascmd.update()
----*******************************************************


]]>
</script>


</muclient>
